/* automatically generated by rust-bindgen */

pub const NVML_API_VERSION: u32 = 10;
pub const NVML_API_VERSION_STR: &'static [u8; 3usize] = b"10\0";
pub const NVML_VALUE_NOT_AVAILABLE: i32 = -1;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_SIZE: u32 = 32;
pub const NVML_DEVICE_PCI_BUS_ID_BUFFER_V2_SIZE: u32 = 16;
pub const NVML_DEVICE_PCI_BUS_ID_LEGACY_FMT: &'static [u8; 17usize] = b"%04X:%02X:%02X.0\0";
pub const NVML_DEVICE_PCI_BUS_ID_FMT: &'static [u8; 17usize] = b"%08X:%02X:%02X.0\0";
pub const NVML_NVLINK_MAX_LINKS: u32 = 6;
pub const NVML_MAX_PHYSICAL_BRIDGE: u32 = 128;
pub const nvmlFlagDefault: u32 = 0;
pub const nvmlFlagForce: u32 = 1;
pub const NVML_FI_DEV_ECC_CURRENT: u32 = 1;
pub const NVML_FI_DEV_ECC_PENDING: u32 = 2;
pub const NVML_FI_DEV_ECC_SBE_VOL_TOTAL: u32 = 3;
pub const NVML_FI_DEV_ECC_DBE_VOL_TOTAL: u32 = 4;
pub const NVML_FI_DEV_ECC_SBE_AGG_TOTAL: u32 = 5;
pub const NVML_FI_DEV_ECC_DBE_AGG_TOTAL: u32 = 6;
pub const NVML_FI_DEV_ECC_SBE_VOL_L1: u32 = 7;
pub const NVML_FI_DEV_ECC_DBE_VOL_L1: u32 = 8;
pub const NVML_FI_DEV_ECC_SBE_VOL_L2: u32 = 9;
pub const NVML_FI_DEV_ECC_DBE_VOL_L2: u32 = 10;
pub const NVML_FI_DEV_ECC_SBE_VOL_DEV: u32 = 11;
pub const NVML_FI_DEV_ECC_DBE_VOL_DEV: u32 = 12;
pub const NVML_FI_DEV_ECC_SBE_VOL_REG: u32 = 13;
pub const NVML_FI_DEV_ECC_DBE_VOL_REG: u32 = 14;
pub const NVML_FI_DEV_ECC_SBE_VOL_TEX: u32 = 15;
pub const NVML_FI_DEV_ECC_DBE_VOL_TEX: u32 = 16;
pub const NVML_FI_DEV_ECC_DBE_VOL_CBU: u32 = 17;
pub const NVML_FI_DEV_ECC_SBE_AGG_L1: u32 = 18;
pub const NVML_FI_DEV_ECC_DBE_AGG_L1: u32 = 19;
pub const NVML_FI_DEV_ECC_SBE_AGG_L2: u32 = 20;
pub const NVML_FI_DEV_ECC_DBE_AGG_L2: u32 = 21;
pub const NVML_FI_DEV_ECC_SBE_AGG_DEV: u32 = 22;
pub const NVML_FI_DEV_ECC_DBE_AGG_DEV: u32 = 23;
pub const NVML_FI_DEV_ECC_SBE_AGG_REG: u32 = 24;
pub const NVML_FI_DEV_ECC_DBE_AGG_REG: u32 = 25;
pub const NVML_FI_DEV_ECC_SBE_AGG_TEX: u32 = 26;
pub const NVML_FI_DEV_ECC_DBE_AGG_TEX: u32 = 27;
pub const NVML_FI_DEV_ECC_DBE_AGG_CBU: u32 = 28;
pub const NVML_FI_DEV_RETIRED_SBE: u32 = 29;
pub const NVML_FI_DEV_RETIRED_DBE: u32 = 30;
pub const NVML_FI_DEV_RETIRED_PENDING: u32 = 31;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L0: u32 = 32;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L1: u32 = 33;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L2: u32 = 34;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L3: u32 = 35;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L4: u32 = 36;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_L5: u32 = 37;
pub const NVML_FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL: u32 = 38;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L0: u32 = 39;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L1: u32 = 40;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L2: u32 = 41;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L3: u32 = 42;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L4: u32 = 43;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_L5: u32 = 44;
pub const NVML_FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL: u32 = 45;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L0: u32 = 46;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L1: u32 = 47;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L2: u32 = 48;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L3: u32 = 49;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L4: u32 = 50;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_L5: u32 = 51;
pub const NVML_FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL: u32 = 52;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L0: u32 = 53;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L1: u32 = 54;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L2: u32 = 55;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L3: u32 = 56;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L4: u32 = 57;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_L5: u32 = 58;
pub const NVML_FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL: u32 = 59;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L0: u32 = 60;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L1: u32 = 61;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L2: u32 = 62;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L3: u32 = 63;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L4: u32 = 64;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_L5: u32 = 65;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C0_TOTAL: u32 = 66;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L0: u32 = 67;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L1: u32 = 68;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L2: u32 = 69;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L3: u32 = 70;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L4: u32 = 71;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_L5: u32 = 72;
pub const NVML_FI_DEV_NVLINK_BANDWIDTH_C1_TOTAL: u32 = 73;
pub const NVML_FI_DEV_PERF_POLICY_POWER: u32 = 74;
pub const NVML_FI_DEV_PERF_POLICY_THERMAL: u32 = 75;
pub const NVML_FI_DEV_PERF_POLICY_SYNC_BOOST: u32 = 76;
pub const NVML_FI_DEV_PERF_POLICY_BOARD_LIMIT: u32 = 77;
pub const NVML_FI_DEV_PERF_POLICY_LOW_UTILIZATION: u32 = 78;
pub const NVML_FI_DEV_PERF_POLICY_RELIABILITY: u32 = 79;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_APP_CLOCKS: u32 = 80;
pub const NVML_FI_DEV_PERF_POLICY_TOTAL_BASE_CLOCKS: u32 = 81;
pub const NVML_FI_DEV_MEMORY_TEMP: u32 = 82;
pub const NVML_FI_DEV_TOTAL_ENERGY_CONSUMPTION: u32 = 83;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L0: u32 = 84;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L1: u32 = 85;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L2: u32 = 86;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L3: u32 = 87;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L4: u32 = 88;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_L5: u32 = 89;
pub const NVML_FI_DEV_NVLINK_SPEED_MBPS_COMMON: u32 = 90;
pub const NVML_FI_DEV_NVLINK_LINK_COUNT: u32 = 91;
pub const NVML_FI_DEV_RETIRED_PENDING_SBE: u32 = 92;
pub const NVML_FI_DEV_RETIRED_PENDING_DBE: u32 = 93;
pub const NVML_FI_DEV_PCIE_REPLAY_COUNTER: u32 = 94;
pub const NVML_FI_DEV_PCIE_REPLAY_ROLLOVER_COUNTER: u32 = 95;
pub const NVML_FI_MAX: u32 = 96;
pub const nvmlEventTypeSingleBitEccError: u32 = 1;
pub const nvmlEventTypeDoubleBitEccError: u32 = 2;
pub const nvmlEventTypePState: u32 = 4;
pub const nvmlEventTypeXidCriticalError: u32 = 8;
pub const nvmlEventTypeClock: u32 = 16;
pub const nvmlEventTypeNone: u32 = 0;
pub const nvmlEventTypeAll: u32 = 31;
pub const nvmlClocksThrottleReasonGpuIdle: u32 = 1;
pub const nvmlClocksThrottleReasonApplicationsClocksSetting: u32 = 2;
pub const nvmlClocksThrottleReasonUserDefinedClocks: u32 = 2;
pub const nvmlClocksThrottleReasonSwPowerCap: u32 = 4;
pub const nvmlClocksThrottleReasonHwSlowdown: u32 = 8;
pub const nvmlClocksThrottleReasonSyncBoost: u32 = 16;
pub const nvmlClocksThrottleReasonSwThermalSlowdown: u32 = 32;
pub const nvmlClocksThrottleReasonHwThermalSlowdown: u32 = 64;
pub const nvmlClocksThrottleReasonHwPowerBrakeSlowdown: u32 = 128;
pub const nvmlClocksThrottleReasonDisplayClockSetting: u32 = 256;
pub const nvmlClocksThrottleReasonNone: u32 = 0;
pub const NVML_GRID_LICENSE_BUFFER_SIZE: u32 = 128;
pub const NVML_VGPU_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_GRID_LICENSE_FEATURE_MAX_COUNT: u32 = 3;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_NO: u32 = 0;
pub const NVML_VGPU_PGPU_VIRTUALIZATION_CAP_MIGRATION_YES: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_DIFFMAP_ENABLED: u32 = 1;
pub const NVML_NVFBC_SESSION_FLAG_CLASSIFICATIONMAP_ENABLED: u32 = 2;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_NO_WAIT: u32 = 4;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_INFINITE: u32 = 8;
pub const NVML_NVFBC_SESSION_FLAG_CAPTURE_WITH_WAIT_TIMEOUT: u32 = 16;
pub const NVML_INIT_FLAG_NO_GPUS: u32 = 1;
pub const NVML_INIT_FLAG_NO_ATTACH: u32 = 2;
pub const NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE: u32 = 16;
pub const NVML_DEVICE_UUID_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_PART_NUMBER_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE: u32 = 80;
pub const NVML_DEVICE_NAME_BUFFER_SIZE: u32 = 64;
pub const NVML_DEVICE_SERIAL_BUFFER_SIZE: u32 = 30;
pub const NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE: u32 = 32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlDevice_st {
    _unused: [u8; 0],
}
pub type nvmlDevice_t = *mut nvmlDevice_st;
#[doc = " PCI information about a GPU device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlPciInfo_st {
    #[doc = "!< The legacy tuple domain:bus:device.function PCI identifier (&amp; NULL terminator)"]
    pub busIdLegacy: [::std::os::raw::c_char; 16usize],
    #[doc = "!< The PCI domain on which the device's bus resides, 0 to 0xffffffff"]
    pub domain: ::std::os::raw::c_uint,
    #[doc = "!< The bus on which the device resides, 0 to 0xff"]
    pub bus: ::std::os::raw::c_uint,
    #[doc = "!< The device's id on the bus, 0 to 31"]
    pub device: ::std::os::raw::c_uint,
    #[doc = "!< The combined 16-bit device id and 16-bit vendor id"]
    pub pciDeviceId: ::std::os::raw::c_uint,
    #[doc = "!< The 32-bit Sub System Device ID"]
    pub pciSubSystemId: ::std::os::raw::c_uint,
    #[doc = "!< The tuple domain:bus:device.function PCI identifier (&amp; NULL terminator)"]
    pub busId: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlPciInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlPciInfo_st>(),
        68usize,
        concat!("Size of: ", stringify!(nvmlPciInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlPciInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlPciInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).busIdLegacy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(busIdLegacy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).domain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).bus as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).device as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).pciDeviceId as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(pciDeviceId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).pciSubSystemId as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(pciSubSystemId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPciInfo_st>())).busId as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPciInfo_st),
            "::",
            stringify!(busId)
        )
    );
}
pub type nvmlPciInfo_t = nvmlPciInfo_st;
#[doc = " Detailed ECC error counts for a device."]
#[doc = ""]
#[doc = " @deprecated  Different GPU families can have different memory error counters"]
#[doc = "              See \\ref nvmlDeviceGetMemoryErrorCounter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEccErrorCounts_st {
    #[doc = "!< L1 cache errors"]
    pub l1Cache: ::std::os::raw::c_ulonglong,
    #[doc = "!< L2 cache errors"]
    pub l2Cache: ::std::os::raw::c_ulonglong,
    #[doc = "!< Device memory errors"]
    pub deviceMemory: ::std::os::raw::c_ulonglong,
    #[doc = "!< Register file errors"]
    pub registerFile: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEccErrorCounts_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlEccErrorCounts_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlEccErrorCounts_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlEccErrorCounts_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlEccErrorCounts_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).l1Cache as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(l1Cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).l2Cache as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(l2Cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).deviceMemory as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(deviceMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEccErrorCounts_st>())).registerFile as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEccErrorCounts_st),
            "::",
            stringify!(registerFile)
        )
    );
}
pub type nvmlEccErrorCounts_t = nvmlEccErrorCounts_st;
#[doc = " Utilization information for a device."]
#[doc = " Each sample period may be between 1 second and 1/6 second, depending on the product being queried."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUtilization_st {
    #[doc = "!< Percent of time over the past sample period during which one or more kernels was executing on the GPU"]
    pub gpu: ::std::os::raw::c_uint,
    #[doc = "!< Percent of time over the past sample period during which global (device) memory was being read or written"]
    pub memory: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUtilization_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUtilization_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlUtilization_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUtilization_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlUtilization_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUtilization_st>())).gpu as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUtilization_st),
            "::",
            stringify!(gpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUtilization_st>())).memory as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUtilization_st),
            "::",
            stringify!(memory)
        )
    );
}
pub type nvmlUtilization_t = nvmlUtilization_st;
#[doc = " Memory allocation information for a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlMemory_st {
    #[doc = "!< Total installed FB memory (in bytes)"]
    pub total: ::std::os::raw::c_ulonglong,
    #[doc = "!< Unallocated FB memory (in bytes)"]
    pub free: ::std::os::raw::c_ulonglong,
    #[doc = "!< Allocated FB memory (in bytes). Note that the driver/GPU always sets aside a small amount of memory for bookkeeping"]
    pub used: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlMemory_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlMemory_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlMemory_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlMemory_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlMemory_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlMemory_st>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlMemory_st),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlMemory_st>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlMemory_st),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlMemory_st>())).used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlMemory_st),
            "::",
            stringify!(used)
        )
    );
}
pub type nvmlMemory_t = nvmlMemory_st;
#[doc = " BAR1 Memory allocation Information for a device"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBAR1Memory_st {
    #[doc = "!< Total BAR1 Memory (in bytes)"]
    pub bar1Total: ::std::os::raw::c_ulonglong,
    #[doc = "!< Unallocated BAR1 Memory (in bytes)"]
    pub bar1Free: ::std::os::raw::c_ulonglong,
    #[doc = "!< Allocated Used Memory (in bytes)"]
    pub bar1Used: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlBAR1Memory_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBAR1Memory_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlBAR1Memory_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBAR1Memory_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlBAR1Memory_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBAR1Memory_st>())).bar1Total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBAR1Memory_st),
            "::",
            stringify!(bar1Total)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBAR1Memory_st>())).bar1Free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBAR1Memory_st),
            "::",
            stringify!(bar1Free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBAR1Memory_st>())).bar1Used as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBAR1Memory_st),
            "::",
            stringify!(bar1Used)
        )
    );
}
pub type nvmlBAR1Memory_t = nvmlBAR1Memory_st;
#[doc = " Information about running compute processes on the GPU"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessInfo_st {
    #[doc = "!< Process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Amount of used GPU memory in bytes."]
    pub usedGpuMemory: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlProcessInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlProcessInfo_st>(),
        16usize,
        concat!("Size of: ", stringify!(nvmlProcessInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlProcessInfo_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlProcessInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlProcessInfo_st>())).pid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessInfo_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessInfo_st>())).usedGpuMemory as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessInfo_st),
            "::",
            stringify!(usedGpuMemory)
        )
    );
}
pub type nvmlProcessInfo_t = nvmlProcessInfo_st;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_PLX: nvmlBridgeChipType_enum = 0;
pub const nvmlBridgeChipType_enum_NVML_BRIDGE_CHIP_BRO4: nvmlBridgeChipType_enum = 1;
#[doc = " Enum to represent type of bridge chip"]
pub type nvmlBridgeChipType_enum = u32;
pub use self::nvmlBridgeChipType_enum as nvmlBridgeChipType_t;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_CYCLES:
    nvmlNvLinkUtilizationCountUnits_enum = 0;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_PACKETS:
    nvmlNvLinkUtilizationCountUnits_enum = 1;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_BYTES:
    nvmlNvLinkUtilizationCountUnits_enum = 2;
pub const nvmlNvLinkUtilizationCountUnits_enum_NVML_NVLINK_COUNTER_UNIT_COUNT:
    nvmlNvLinkUtilizationCountUnits_enum = 3;
#[doc = " Enum to represent the NvLink utilization counter packet units"]
pub type nvmlNvLinkUtilizationCountUnits_enum = u32;
pub use self::nvmlNvLinkUtilizationCountUnits_enum as nvmlNvLinkUtilizationCountUnits_t;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NOP:
    nvmlNvLinkUtilizationCountPktTypes_enum = 1;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_READ:
    nvmlNvLinkUtilizationCountPktTypes_enum = 2;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_WRITE:
    nvmlNvLinkUtilizationCountPktTypes_enum = 4;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 8;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_NRATOM:
    nvmlNvLinkUtilizationCountPktTypes_enum = 16;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_FLUSH:
    nvmlNvLinkUtilizationCountPktTypes_enum = 32;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPDATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 64;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_RESPNODATA:
    nvmlNvLinkUtilizationCountPktTypes_enum = 128;
pub const nvmlNvLinkUtilizationCountPktTypes_enum_NVML_NVLINK_COUNTER_PKTFILTER_ALL:
    nvmlNvLinkUtilizationCountPktTypes_enum = 255;
#[doc = " Enum to represent the NvLink utilization counter packet types to count"]
#[doc = "  ** this is ONLY applicable with the units as packets or bytes"]
#[doc = "  ** as specified in \\a nvmlNvLinkUtilizationCountUnits_t"]
#[doc = "  ** all packet filter descriptions are target GPU centric"]
#[doc = "  ** these can be \"OR'd\" together"]
pub type nvmlNvLinkUtilizationCountPktTypes_enum = u32;
pub use self::nvmlNvLinkUtilizationCountPktTypes_enum as nvmlNvLinkUtilizationCountPktTypes_t;
#[doc = " Struct to define the NVLINK counter controls"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlNvLinkUtilizationControl_st {
    pub units: nvmlNvLinkUtilizationCountUnits_t,
    pub pktfilter: nvmlNvLinkUtilizationCountPktTypes_t,
}
#[test]
fn bindgen_test_layout_nvmlNvLinkUtilizationControl_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlNvLinkUtilizationControl_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlNvLinkUtilizationControl_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlNvLinkUtilizationControl_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlNvLinkUtilizationControl_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlNvLinkUtilizationControl_st>())).units as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlNvLinkUtilizationControl_st),
            "::",
            stringify!(units)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlNvLinkUtilizationControl_st>())).pktfilter as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlNvLinkUtilizationControl_st),
            "::",
            stringify!(pktfilter)
        )
    );
}
pub type nvmlNvLinkUtilizationControl_t = nvmlNvLinkUtilizationControl_st;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_SUPPORTED: nvmlNvLinkCapability_enum = 0;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ACCESS: nvmlNvLinkCapability_enum = 1;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_P2P_ATOMICS: nvmlNvLinkCapability_enum = 2;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SYSMEM_ATOMICS: nvmlNvLinkCapability_enum = 3;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_SLI_BRIDGE: nvmlNvLinkCapability_enum = 4;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_VALID: nvmlNvLinkCapability_enum = 5;
pub const nvmlNvLinkCapability_enum_NVML_NVLINK_CAP_COUNT: nvmlNvLinkCapability_enum = 6;
#[doc = " Enum to represent NvLink queryable capabilities"]
pub type nvmlNvLinkCapability_enum = u32;
pub use self::nvmlNvLinkCapability_enum as nvmlNvLinkCapability_t;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_REPLAY: nvmlNvLinkErrorCounter_enum = 0;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_RECOVERY: nvmlNvLinkErrorCounter_enum =
    1;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_FLIT: nvmlNvLinkErrorCounter_enum =
    2;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_DL_CRC_DATA: nvmlNvLinkErrorCounter_enum =
    3;
pub const nvmlNvLinkErrorCounter_enum_NVML_NVLINK_ERROR_COUNT: nvmlNvLinkErrorCounter_enum = 4;
#[doc = " Enum to represent NvLink queryable error counters"]
pub type nvmlNvLinkErrorCounter_enum = u32;
pub use self::nvmlNvLinkErrorCounter_enum as nvmlNvLinkErrorCounter_t;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_INTERNAL: nvmlGpuLevel_enum = 0;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SINGLE: nvmlGpuLevel_enum = 10;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_MULTIPLE: nvmlGpuLevel_enum = 20;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_HOSTBRIDGE: nvmlGpuLevel_enum = 30;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_NODE: nvmlGpuLevel_enum = 40;
pub const nvmlGpuLevel_enum_NVML_TOPOLOGY_SYSTEM: nvmlGpuLevel_enum = 50;
#[doc = " Represents level relationships within a system between two GPUs"]
#[doc = " The enums are spaced to allow for future relationships"]
pub type nvmlGpuLevel_enum = u32;
pub use self::nvmlGpuLevel_enum as nvmlGpuTopologyLevel_t;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_OK: nvmlGpuP2PStatus_enum = 0;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_CHIPSET_NOT_SUPPORED: nvmlGpuP2PStatus_enum = 1;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_GPU_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 2;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_IOH_TOPOLOGY_NOT_SUPPORTED: nvmlGpuP2PStatus_enum =
    3;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_DISABLED_BY_REGKEY: nvmlGpuP2PStatus_enum = 4;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_NOT_SUPPORTED: nvmlGpuP2PStatus_enum = 5;
pub const nvmlGpuP2PStatus_enum_NVML_P2P_STATUS_UNKNOWN: nvmlGpuP2PStatus_enum = 6;
pub type nvmlGpuP2PStatus_enum = u32;
pub use self::nvmlGpuP2PStatus_enum as nvmlGpuP2PStatus_t;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_READ: nvmlGpuP2PCapsIndex_enum = 0;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_WRITE: nvmlGpuP2PCapsIndex_enum = 1;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_NVLINK: nvmlGpuP2PCapsIndex_enum = 2;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_ATOMICS: nvmlGpuP2PCapsIndex_enum = 3;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_PROP: nvmlGpuP2PCapsIndex_enum = 4;
pub const nvmlGpuP2PCapsIndex_enum_NVML_P2P_CAPS_INDEX_UNKNOWN: nvmlGpuP2PCapsIndex_enum = 5;
pub type nvmlGpuP2PCapsIndex_enum = u32;
pub use self::nvmlGpuP2PCapsIndex_enum as nvmlGpuP2PCapsIndex_t;
#[doc = " Information about the Bridge Chip Firmware"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlBridgeChipInfo_st {
    #[doc = "!< Type of Bridge Chip"]
    pub type_: nvmlBridgeChipType_t,
    #[doc = "!< Firmware Version. 0=Version is unavailable"]
    pub fwVersion: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBridgeChipInfo_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlBridgeChipInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBridgeChipInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlBridgeChipInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBridgeChipInfo_st>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipInfo_st),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBridgeChipInfo_st>())).fwVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipInfo_st),
            "::",
            stringify!(fwVersion)
        )
    );
}
pub type nvmlBridgeChipInfo_t = nvmlBridgeChipInfo_st;
#[doc = " This structure stores the complete Hierarchy of the Bridge Chip within the board. The immediate"]
#[doc = " bridge is stored at index 0 of bridgeInfoList, parent to immediate bridge is at index 1 and so forth."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBridgeChipHierarchy_st {
    #[doc = "!< Number of Bridge Chips on the Board"]
    pub bridgeCount: ::std::os::raw::c_uchar,
    #[doc = "!< Hierarchy of Bridge Chips on the board"]
    pub bridgeChipInfo: [nvmlBridgeChipInfo_t; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlBridgeChipHierarchy_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBridgeChipHierarchy_st>(),
        1028usize,
        concat!("Size of: ", stringify!(nvmlBridgeChipHierarchy_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBridgeChipHierarchy_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlBridgeChipHierarchy_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlBridgeChipHierarchy_st>())).bridgeCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipHierarchy_st),
            "::",
            stringify!(bridgeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlBridgeChipHierarchy_st>())).bridgeChipInfo as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBridgeChipHierarchy_st),
            "::",
            stringify!(bridgeChipInfo)
        )
    );
}
pub type nvmlBridgeChipHierarchy_t = nvmlBridgeChipHierarchy_st;
#[doc = "!< To represent total power drawn by GPU"]
pub const nvmlSamplingType_enum_NVML_TOTAL_POWER_SAMPLES: nvmlSamplingType_enum = 0;
#[doc = "!< To represent percent of time during which one or more kernels was executing on the GPU"]
pub const nvmlSamplingType_enum_NVML_GPU_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 1;
#[doc = "!< To represent percent of time during which global (device) memory was being read or written"]
pub const nvmlSamplingType_enum_NVML_MEMORY_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 2;
#[doc = "!< To represent percent of time during which NVENC remains busy"]
pub const nvmlSamplingType_enum_NVML_ENC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 3;
#[doc = "!< To represent percent of time during which NVDEC remains busy"]
pub const nvmlSamplingType_enum_NVML_DEC_UTILIZATION_SAMPLES: nvmlSamplingType_enum = 4;
#[doc = "!< To represent processor clock samples"]
pub const nvmlSamplingType_enum_NVML_PROCESSOR_CLK_SAMPLES: nvmlSamplingType_enum = 5;
#[doc = "!< To represent memory clock samples"]
pub const nvmlSamplingType_enum_NVML_MEMORY_CLK_SAMPLES: nvmlSamplingType_enum = 6;
pub const nvmlSamplingType_enum_NVML_SAMPLINGTYPE_COUNT: nvmlSamplingType_enum = 7;
#[doc = "  Represents Type of Sampling Event"]
pub type nvmlSamplingType_enum = u32;
pub use self::nvmlSamplingType_enum as nvmlSamplingType_t;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_TX_BYTES: nvmlPcieUtilCounter_enum = 0;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_RX_BYTES: nvmlPcieUtilCounter_enum = 1;
pub const nvmlPcieUtilCounter_enum_NVML_PCIE_UTIL_COUNT: nvmlPcieUtilCounter_enum = 2;
#[doc = " Represents the queryable PCIe utilization counters"]
pub type nvmlPcieUtilCounter_enum = u32;
pub use self::nvmlPcieUtilCounter_enum as nvmlPcieUtilCounter_t;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_DOUBLE: nvmlValueType_enum = 0;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_INT: nvmlValueType_enum = 1;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG: nvmlValueType_enum = 2;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_UNSIGNED_LONG_LONG: nvmlValueType_enum = 3;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_SIGNED_LONG_LONG: nvmlValueType_enum = 4;
pub const nvmlValueType_enum_NVML_VALUE_TYPE_COUNT: nvmlValueType_enum = 5;
#[doc = " Represents the type for sample value returned"]
pub type nvmlValueType_enum = u32;
pub use self::nvmlValueType_enum as nvmlValueType_t;
#[doc = " Union to represent different types of Value"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union nvmlValue_st {
    #[doc = "!< If the value is double"]
    pub dVal: f64,
    #[doc = "!< If the value is unsigned int"]
    pub uiVal: ::std::os::raw::c_uint,
    #[doc = "!< If the value is unsigned long"]
    pub ulVal: ::std::os::raw::c_ulong,
    #[doc = "!< If the value is unsigned long long"]
    pub ullVal: ::std::os::raw::c_ulonglong,
    #[doc = "!< If the value is signed long long"]
    pub sllVal: ::std::os::raw::c_longlong,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_nvmlValue_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlValue_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlValue_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlValue_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlValue_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).dVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(dVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).uiVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(uiVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).ulVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(ulVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).ullVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(ullVal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlValue_st>())).sllVal as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlValue_st),
            "::",
            stringify!(sllVal)
        )
    );
}
pub type nvmlValue_t = nvmlValue_st;
#[doc = " Information for Sample"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlSample_st {
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< Sample Value"]
    pub sampleValue: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlSample_st>(),
        16usize,
        concat!("Size of: ", stringify!(nvmlSample_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlSample_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlSample_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlSample_st>())).timeStamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlSample_st>())).sampleValue as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlSample_st),
            "::",
            stringify!(sampleValue)
        )
    );
}
pub type nvmlSample_t = nvmlSample_st;
#[doc = "!< How long did power violations cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_POWER: nvmlPerfPolicyType_enum = 0;
#[doc = "!< How long did thermal violations cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_THERMAL: nvmlPerfPolicyType_enum = 1;
#[doc = "!< How long did sync boost cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_SYNC_BOOST: nvmlPerfPolicyType_enum = 2;
#[doc = "!< How long did the board limit cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_BOARD_LIMIT: nvmlPerfPolicyType_enum = 3;
#[doc = "!< How long did low utilization cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_LOW_UTILIZATION: nvmlPerfPolicyType_enum = 4;
#[doc = "!< How long did the board reliability limit cause the GPU to be below application clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_RELIABILITY: nvmlPerfPolicyType_enum = 5;
#[doc = "!< Total time the GPU was held below application clocks by any limiter (0 - 5 above)"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_APP_CLOCKS: nvmlPerfPolicyType_enum = 10;
#[doc = "!< Total time the GPU was held below base clocks"]
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_TOTAL_BASE_CLOCKS: nvmlPerfPolicyType_enum = 11;
pub const nvmlPerfPolicyType_enum_NVML_PERF_POLICY_COUNT: nvmlPerfPolicyType_enum = 12;
#[doc = " Represents type of perf policy for which violation times can be queried"]
pub type nvmlPerfPolicyType_enum = u32;
pub use self::nvmlPerfPolicyType_enum as nvmlPerfPolicyType_t;
#[doc = " Struct to hold perf policy violation status data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlViolationTime_st {
    #[doc = "!< referenceTime represents CPU timestamp in microseconds"]
    pub referenceTime: ::std::os::raw::c_ulonglong,
    #[doc = "!< violationTime in Nanoseconds"]
    pub violationTime: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlViolationTime_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlViolationTime_st>(),
        16usize,
        concat!("Size of: ", stringify!(nvmlViolationTime_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlViolationTime_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlViolationTime_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlViolationTime_st>())).referenceTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlViolationTime_st),
            "::",
            stringify!(referenceTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlViolationTime_st>())).violationTime as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlViolationTime_st),
            "::",
            stringify!(violationTime)
        )
    );
}
pub type nvmlViolationTime_t = nvmlViolationTime_st;
#[doc = "!< Feature disabled"]
pub const nvmlEnableState_enum_NVML_FEATURE_DISABLED: nvmlEnableState_enum = 0;
#[doc = "!< Feature enabled"]
pub const nvmlEnableState_enum_NVML_FEATURE_ENABLED: nvmlEnableState_enum = 1;
#[doc = " Generic enable/disable enum."]
pub type nvmlEnableState_enum = u32;
pub use self::nvmlEnableState_enum as nvmlEnableState_t;
pub const nvmlBrandType_enum_NVML_BRAND_UNKNOWN: nvmlBrandType_enum = 0;
pub const nvmlBrandType_enum_NVML_BRAND_QUADRO: nvmlBrandType_enum = 1;
pub const nvmlBrandType_enum_NVML_BRAND_TESLA: nvmlBrandType_enum = 2;
pub const nvmlBrandType_enum_NVML_BRAND_NVS: nvmlBrandType_enum = 3;
pub const nvmlBrandType_enum_NVML_BRAND_GRID: nvmlBrandType_enum = 4;
pub const nvmlBrandType_enum_NVML_BRAND_GEFORCE: nvmlBrandType_enum = 5;
pub const nvmlBrandType_enum_NVML_BRAND_TITAN: nvmlBrandType_enum = 6;
pub const nvmlBrandType_enum_NVML_BRAND_COUNT: nvmlBrandType_enum = 7;
#[doc = "  * The Brand of the GPU"]
pub type nvmlBrandType_enum = u32;
pub use self::nvmlBrandType_enum as nvmlBrandType_t;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SHUTDOWN:
    nvmlTemperatureThresholds_enum = 0;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_SLOWDOWN:
    nvmlTemperatureThresholds_enum = 1;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_MEM_MAX:
    nvmlTemperatureThresholds_enum = 2;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_GPU_MAX:
    nvmlTemperatureThresholds_enum = 3;
pub const nvmlTemperatureThresholds_enum_NVML_TEMPERATURE_THRESHOLD_COUNT:
    nvmlTemperatureThresholds_enum = 4;
#[doc = " Temperature thresholds."]
pub type nvmlTemperatureThresholds_enum = u32;
pub use self::nvmlTemperatureThresholds_enum as nvmlTemperatureThresholds_t;
#[doc = "!< Temperature sensor for the GPU die"]
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_GPU: nvmlTemperatureSensors_enum = 0;
pub const nvmlTemperatureSensors_enum_NVML_TEMPERATURE_COUNT: nvmlTemperatureSensors_enum = 1;
#[doc = " Temperature sensors."]
pub type nvmlTemperatureSensors_enum = u32;
pub use self::nvmlTemperatureSensors_enum as nvmlTemperatureSensors_t;
#[doc = "!< Default compute mode -- multiple contexts per device"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_DEFAULT: nvmlComputeMode_enum = 0;
#[doc = "!< Support Removed"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_THREAD: nvmlComputeMode_enum = 1;
#[doc = "!< Compute-prohibited mode -- no contexts per device"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_PROHIBITED: nvmlComputeMode_enum = 2;
#[doc = "!< Compute-exclusive-process mode -- only one context per device, usable from multiple threads at a time"]
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_EXCLUSIVE_PROCESS: nvmlComputeMode_enum = 3;
pub const nvmlComputeMode_enum_NVML_COMPUTEMODE_COUNT: nvmlComputeMode_enum = 4;
#[doc = " Compute mode."]
#[doc = ""]
#[doc = " NVML_COMPUTEMODE_EXCLUSIVE_PROCESS was added in CUDA 4.0."]
#[doc = " Earlier CUDA versions supported a single exclusive mode,"]
#[doc = " which is equivalent to NVML_COMPUTEMODE_EXCLUSIVE_THREAD in CUDA 4.0 and beyond."]
pub type nvmlComputeMode_enum = u32;
pub use self::nvmlComputeMode_enum as nvmlComputeMode_t;
#[doc = " A memory error that was corrected"]
#[doc = ""]
#[doc = " For ECC errors, these are single bit errors"]
#[doc = " For Texture memory, these are errors fixed by resend"]
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_CORRECTED: nvmlMemoryErrorType_enum = 0;
#[doc = " A memory error that was not corrected"]
#[doc = ""]
#[doc = " For ECC errors, these are double bit errors"]
#[doc = " For Texture memory, these are errors where the resend fails"]
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_UNCORRECTED: nvmlMemoryErrorType_enum = 1;
#[doc = "!< Count of memory error types"]
pub const nvmlMemoryErrorType_enum_NVML_MEMORY_ERROR_TYPE_COUNT: nvmlMemoryErrorType_enum = 2;
#[doc = " Memory error types"]
pub type nvmlMemoryErrorType_enum = u32;
pub use self::nvmlMemoryErrorType_enum as nvmlMemoryErrorType_t;
#[doc = "!< Volatile counts are reset each time the driver loads."]
pub const nvmlEccCounterType_enum_NVML_VOLATILE_ECC: nvmlEccCounterType_enum = 0;
#[doc = "!< Aggregate counts persist across reboots (i.e. for the lifetime of the device)"]
pub const nvmlEccCounterType_enum_NVML_AGGREGATE_ECC: nvmlEccCounterType_enum = 1;
#[doc = "!< Count of memory counter types"]
pub const nvmlEccCounterType_enum_NVML_ECC_COUNTER_TYPE_COUNT: nvmlEccCounterType_enum = 2;
#[doc = " ECC counter types."]
#[doc = ""]
#[doc = " Note: Volatile counts are reset each time the driver loads. On Windows this is once per boot. On Linux this can be more frequent."]
#[doc = "       On Linux the driver unloads when no active clients exist. If persistence mode is enabled or there is always a driver"]
#[doc = "       client active (e.g. X11), then Linux also sees per-boot behavior. If not, volatile counts are reset each time a compute app"]
#[doc = "       is run."]
pub type nvmlEccCounterType_enum = u32;
pub use self::nvmlEccCounterType_enum as nvmlEccCounterType_t;
#[doc = "!< Graphics clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_GRAPHICS: nvmlClockType_enum = 0;
#[doc = "!< SM clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_SM: nvmlClockType_enum = 1;
#[doc = "!< Memory clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_MEM: nvmlClockType_enum = 2;
#[doc = "!< Video encoder/decoder clock domain"]
pub const nvmlClockType_enum_NVML_CLOCK_VIDEO: nvmlClockType_enum = 3;
#[doc = "!< Count of clock types"]
pub const nvmlClockType_enum_NVML_CLOCK_COUNT: nvmlClockType_enum = 4;
#[doc = " Clock types."]
#[doc = ""]
#[doc = " All speeds are in Mhz."]
pub type nvmlClockType_enum = u32;
pub use self::nvmlClockType_enum as nvmlClockType_t;
#[doc = "!< Current actual clock value"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_CURRENT: nvmlClockId_enum = 0;
#[doc = "!< Target application clock"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_TARGET: nvmlClockId_enum = 1;
#[doc = "!< Default application clock target"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_APP_CLOCK_DEFAULT: nvmlClockId_enum = 2;
#[doc = "!< OEM-defined maximum clock rate"]
pub const nvmlClockId_enum_NVML_CLOCK_ID_CUSTOMER_BOOST_MAX: nvmlClockId_enum = 3;
#[doc = "!< Count of Clock Ids."]
pub const nvmlClockId_enum_NVML_CLOCK_ID_COUNT: nvmlClockId_enum = 4;
#[doc = " Clock Ids.  These are used in combination with nvmlClockType_t"]
#[doc = " to specify a single clock value."]
pub type nvmlClockId_enum = u32;
pub use self::nvmlClockId_enum as nvmlClockId_t;
#[doc = "!< WDDM driver model -- GPU treated as a display device"]
pub const nvmlDriverModel_enum_NVML_DRIVER_WDDM: nvmlDriverModel_enum = 0;
#[doc = "!< WDM (TCC) model (recommended) -- GPU treated as a generic device"]
pub const nvmlDriverModel_enum_NVML_DRIVER_WDM: nvmlDriverModel_enum = 1;
#[doc = " Driver models."]
#[doc = ""]
#[doc = " Windows only."]
pub type nvmlDriverModel_enum = u32;
pub use self::nvmlDriverModel_enum as nvmlDriverModel_t;
#[doc = "!< Performance state 0 -- Maximum Performance"]
pub const nvmlPStates_enum_NVML_PSTATE_0: nvmlPStates_enum = 0;
#[doc = "!< Performance state 1"]
pub const nvmlPStates_enum_NVML_PSTATE_1: nvmlPStates_enum = 1;
#[doc = "!< Performance state 2"]
pub const nvmlPStates_enum_NVML_PSTATE_2: nvmlPStates_enum = 2;
#[doc = "!< Performance state 3"]
pub const nvmlPStates_enum_NVML_PSTATE_3: nvmlPStates_enum = 3;
#[doc = "!< Performance state 4"]
pub const nvmlPStates_enum_NVML_PSTATE_4: nvmlPStates_enum = 4;
#[doc = "!< Performance state 5"]
pub const nvmlPStates_enum_NVML_PSTATE_5: nvmlPStates_enum = 5;
#[doc = "!< Performance state 6"]
pub const nvmlPStates_enum_NVML_PSTATE_6: nvmlPStates_enum = 6;
#[doc = "!< Performance state 7"]
pub const nvmlPStates_enum_NVML_PSTATE_7: nvmlPStates_enum = 7;
#[doc = "!< Performance state 8"]
pub const nvmlPStates_enum_NVML_PSTATE_8: nvmlPStates_enum = 8;
#[doc = "!< Performance state 9"]
pub const nvmlPStates_enum_NVML_PSTATE_9: nvmlPStates_enum = 9;
#[doc = "!< Performance state 10"]
pub const nvmlPStates_enum_NVML_PSTATE_10: nvmlPStates_enum = 10;
#[doc = "!< Performance state 11"]
pub const nvmlPStates_enum_NVML_PSTATE_11: nvmlPStates_enum = 11;
#[doc = "!< Performance state 12"]
pub const nvmlPStates_enum_NVML_PSTATE_12: nvmlPStates_enum = 12;
#[doc = "!< Performance state 13"]
pub const nvmlPStates_enum_NVML_PSTATE_13: nvmlPStates_enum = 13;
#[doc = "!< Performance state 14"]
pub const nvmlPStates_enum_NVML_PSTATE_14: nvmlPStates_enum = 14;
#[doc = "!< Performance state 15 -- Minimum Performance"]
pub const nvmlPStates_enum_NVML_PSTATE_15: nvmlPStates_enum = 15;
#[doc = "!< Unknown performance state"]
pub const nvmlPStates_enum_NVML_PSTATE_UNKNOWN: nvmlPStates_enum = 32;
#[doc = " Allowed PStates."]
pub type nvmlPStates_enum = u32;
pub use self::nvmlPStates_enum as nvmlPstates_t;
#[doc = "!< Everything is enabled and running at full speed"]
pub const nvmlGom_enum_NVML_GOM_ALL_ON: nvmlGom_enum = 0;
#[doc = "!< Designed for running only compute tasks. Graphics operations"]
#[doc = "!< are not allowed"]
pub const nvmlGom_enum_NVML_GOM_COMPUTE: nvmlGom_enum = 1;
#[doc = "!< Designed for running graphics applications that don't require"]
#[doc = "!< high bandwidth double precision"]
pub const nvmlGom_enum_NVML_GOM_LOW_DP: nvmlGom_enum = 2;
#[doc = " GPU Operation Mode"]
#[doc = ""]
#[doc = " GOM allows to reduce power usage and optimize GPU throughput by disabling GPU features."]
#[doc = ""]
#[doc = " Each GOM is designed to meet specific user needs."]
pub type nvmlGom_enum = u32;
pub use self::nvmlGom_enum as nvmlGpuOperationMode_t;
#[doc = "!< An object defined by OEM"]
pub const nvmlInforomObject_enum_NVML_INFOROM_OEM: nvmlInforomObject_enum = 0;
#[doc = "!< The ECC object determining the level of ECC support"]
pub const nvmlInforomObject_enum_NVML_INFOROM_ECC: nvmlInforomObject_enum = 1;
#[doc = "!< The power management object"]
pub const nvmlInforomObject_enum_NVML_INFOROM_POWER: nvmlInforomObject_enum = 2;
#[doc = "!< This counts the number of infoROM objects the driver knows about"]
pub const nvmlInforomObject_enum_NVML_INFOROM_COUNT: nvmlInforomObject_enum = 3;
#[doc = " Available infoROM objects."]
pub type nvmlInforomObject_enum = u32;
pub use self::nvmlInforomObject_enum as nvmlInforomObject_t;
#[doc = "!< The operation was successful"]
pub const nvmlReturn_enum_NVML_SUCCESS: nvmlReturn_enum = 0;
#[doc = "!< NVML was not first initialized with nvmlInit()"]
pub const nvmlReturn_enum_NVML_ERROR_UNINITIALIZED: nvmlReturn_enum = 1;
#[doc = "!< A supplied argument is invalid"]
pub const nvmlReturn_enum_NVML_ERROR_INVALID_ARGUMENT: nvmlReturn_enum = 2;
#[doc = "!< The requested operation is not available on target device"]
pub const nvmlReturn_enum_NVML_ERROR_NOT_SUPPORTED: nvmlReturn_enum = 3;
#[doc = "!< The current user does not have permission for operation"]
pub const nvmlReturn_enum_NVML_ERROR_NO_PERMISSION: nvmlReturn_enum = 4;
#[doc = "!< Deprecated: Multiple initializations are now allowed through ref counting"]
pub const nvmlReturn_enum_NVML_ERROR_ALREADY_INITIALIZED: nvmlReturn_enum = 5;
#[doc = "!< A query to find an object was unsuccessful"]
pub const nvmlReturn_enum_NVML_ERROR_NOT_FOUND: nvmlReturn_enum = 6;
#[doc = "!< An input argument is not large enough"]
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_SIZE: nvmlReturn_enum = 7;
#[doc = "!< A device's external power cables are not properly attached"]
pub const nvmlReturn_enum_NVML_ERROR_INSUFFICIENT_POWER: nvmlReturn_enum = 8;
#[doc = "!< NVIDIA driver is not loaded"]
pub const nvmlReturn_enum_NVML_ERROR_DRIVER_NOT_LOADED: nvmlReturn_enum = 9;
#[doc = "!< User provided timeout passed"]
pub const nvmlReturn_enum_NVML_ERROR_TIMEOUT: nvmlReturn_enum = 10;
#[doc = "!< NVIDIA Kernel detected an interrupt issue with a GPU"]
pub const nvmlReturn_enum_NVML_ERROR_IRQ_ISSUE: nvmlReturn_enum = 11;
#[doc = "!< NVML Shared Library couldn't be found or loaded"]
pub const nvmlReturn_enum_NVML_ERROR_LIBRARY_NOT_FOUND: nvmlReturn_enum = 12;
#[doc = "!< Local version of NVML doesn't implement this function"]
pub const nvmlReturn_enum_NVML_ERROR_FUNCTION_NOT_FOUND: nvmlReturn_enum = 13;
#[doc = "!< infoROM is corrupted"]
pub const nvmlReturn_enum_NVML_ERROR_CORRUPTED_INFOROM: nvmlReturn_enum = 14;
#[doc = "!< The GPU has fallen off the bus or has otherwise become inaccessible"]
pub const nvmlReturn_enum_NVML_ERROR_GPU_IS_LOST: nvmlReturn_enum = 15;
#[doc = "!< The GPU requires a reset before it can be used again"]
pub const nvmlReturn_enum_NVML_ERROR_RESET_REQUIRED: nvmlReturn_enum = 16;
#[doc = "!< The GPU control device has been blocked by the operating system/cgroups"]
pub const nvmlReturn_enum_NVML_ERROR_OPERATING_SYSTEM: nvmlReturn_enum = 17;
#[doc = "!< RM detects a driver/library version mismatch"]
pub const nvmlReturn_enum_NVML_ERROR_LIB_RM_VERSION_MISMATCH: nvmlReturn_enum = 18;
#[doc = "!< An operation cannot be performed because the GPU is currently in use"]
pub const nvmlReturn_enum_NVML_ERROR_IN_USE: nvmlReturn_enum = 19;
#[doc = "!< Insufficient memory"]
pub const nvmlReturn_enum_NVML_ERROR_MEMORY: nvmlReturn_enum = 20;
#[doc = "!<No data"]
pub const nvmlReturn_enum_NVML_ERROR_NO_DATA: nvmlReturn_enum = 21;
#[doc = "!< The requested vgpu operation is not available on target device, becasue ECC is enabled"]
pub const nvmlReturn_enum_NVML_ERROR_VGPU_ECC_NOT_SUPPORTED: nvmlReturn_enum = 22;
#[doc = "!< An internal driver error occurred"]
pub const nvmlReturn_enum_NVML_ERROR_UNKNOWN: nvmlReturn_enum = 999;
#[doc = " Return values for NVML API calls."]
pub type nvmlReturn_enum = u32;
pub use self::nvmlReturn_enum as nvmlReturn_t;
#[doc = "!< GPU L1 Cache"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L1_CACHE: nvmlMemoryLocation_enum = 0;
#[doc = "!< GPU L2 Cache"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_L2_CACHE: nvmlMemoryLocation_enum = 1;
#[doc = "!< Turing+ DRAM"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DRAM: nvmlMemoryLocation_enum = 2;
#[doc = "!< GPU Device Memory"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_DEVICE_MEMORY: nvmlMemoryLocation_enum = 2;
#[doc = "!< GPU Register File"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_REGISTER_FILE: nvmlMemoryLocation_enum = 3;
#[doc = "!< GPU Texture Memory"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_MEMORY: nvmlMemoryLocation_enum = 4;
#[doc = "!< Shared memory"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_TEXTURE_SHM: nvmlMemoryLocation_enum = 5;
#[doc = "!< CBU"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_CBU: nvmlMemoryLocation_enum = 6;
#[doc = "!< Turing+ SRAM"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_SRAM: nvmlMemoryLocation_enum = 7;
#[doc = "!< This counts the number of memory locations the driver knows about"]
pub const nvmlMemoryLocation_enum_NVML_MEMORY_LOCATION_COUNT: nvmlMemoryLocation_enum = 8;
#[doc = " See \\ref nvmlDeviceGetMemoryErrorCounter"]
pub type nvmlMemoryLocation_enum = u32;
pub use self::nvmlMemoryLocation_enum as nvmlMemoryLocation_t;
#[doc = "!< Page was retired due to multiple single bit ECC error"]
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_MULTIPLE_SINGLE_BIT_ECC_ERRORS:
    nvmlPageRetirementCause_enum = 0;
#[doc = "!< Page was retired due to double bit ECC error"]
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_DOUBLE_BIT_ECC_ERROR:
    nvmlPageRetirementCause_enum = 1;
pub const nvmlPageRetirementCause_enum_NVML_PAGE_RETIREMENT_CAUSE_COUNT:
    nvmlPageRetirementCause_enum = 2;
#[doc = " Causes for page retirement"]
pub type nvmlPageRetirementCause_enum = u32;
pub use self::nvmlPageRetirementCause_enum as nvmlPageRetirementCause_t;
#[doc = "!< APIs that change application clocks, see nvmlDeviceSetApplicationsClocks"]
#[doc = "!< and see nvmlDeviceResetApplicationsClocks"]
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_APPLICATION_CLOCKS:
    nvmlRestrictedAPI_enum = 0;
#[doc = "!< APIs that enable/disable Auto Boosted clocks"]
#[doc = "!< see nvmlDeviceSetAutoBoostedClocksEnabled"]
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS:
    nvmlRestrictedAPI_enum = 1;
pub const nvmlRestrictedAPI_enum_NVML_RESTRICTED_API_COUNT: nvmlRestrictedAPI_enum = 2;
#[doc = " API types that allow changes to default permission restrictions"]
pub type nvmlRestrictedAPI_enum = u32;
pub use self::nvmlRestrictedAPI_enum as nvmlRestrictedAPI_t;
#[doc = "!< Represents Bare Metal GPU"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_NONE: nvmlGpuVirtualizationMode =
    0;
#[doc = "!< Device is associated with GPU-Passthorugh"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_PASSTHROUGH:
    nvmlGpuVirtualizationMode = 1;
#[doc = "!< Device is associated with vGPU inside virtual machine."]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_VGPU: nvmlGpuVirtualizationMode =
    2;
#[doc = "!< Device is associated with VGX hypervisor in vGPU mode"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VGPU:
    nvmlGpuVirtualizationMode = 3;
#[doc = "!< Device is associated with VGX hypervisor in vSGA mode"]
pub const nvmlGpuVirtualizationMode_NVML_GPU_VIRTUALIZATION_MODE_HOST_VSGA:
    nvmlGpuVirtualizationMode = 4;
#[doc = " GPU virtualization mode types."]
pub type nvmlGpuVirtualizationMode = u32;
pub use self::nvmlGpuVirtualizationMode as nvmlGpuVirtualizationMode_t;
#[doc = " Information for a Field Value Sample"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlFieldValue_st {
    #[doc = "!< ID of the NVML field to retrieve. This must be set before any call that uses this struct. See the constants starting with NVML_FI_ above."]
    pub fieldId: ::std::os::raw::c_uint,
    #[doc = "!< Currently unused. This should be initialized to 0 by the caller before any API call"]
    pub unused: ::std::os::raw::c_uint,
    #[doc = "!< CPU Timestamp of this value in microseconds since 1970"]
    pub timestamp: ::std::os::raw::c_longlong,
    #[doc = "!< How long this field value took to update (in usec) within NVML. This may be averaged across several fields that are serviced by the same driver call."]
    pub latencyUsec: ::std::os::raw::c_longlong,
    #[doc = "!< Type of the value stored in value"]
    pub valueType: nvmlValueType_t,
    #[doc = "!< Return code for retrieving this value. This must be checked before looking at value, as value is undefined if nvmlReturn != NVML_SUCCESS"]
    pub nvmlReturn: nvmlReturn_t,
    #[doc = "!< Value for this field. This is only valid if nvmlReturn == NVML_SUCCESS"]
    pub value: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlFieldValue_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlFieldValue_st>(),
        40usize,
        concat!("Size of: ", stringify!(nvmlFieldValue_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlFieldValue_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlFieldValue_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).fieldId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(fieldId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).unused as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(unused)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).latencyUsec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(latencyUsec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).valueType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(valueType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).nvmlReturn as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(nvmlReturn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFieldValue_st>())).value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFieldValue_st),
            "::",
            stringify!(value)
        )
    );
}
pub type nvmlFieldValue_t = nvmlFieldValue_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnit_st {
    _unused: [u8; 0],
}
#[doc = "  @{"]
pub type nvmlUnit_t = *mut nvmlUnit_st;
#[doc = " Description of HWBC entry"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlHwbcEntry_st {
    pub hwbcId: ::std::os::raw::c_uint,
    pub firmwareVersion: [::std::os::raw::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_nvmlHwbcEntry_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlHwbcEntry_st>(),
        36usize,
        concat!("Size of: ", stringify!(nvmlHwbcEntry_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlHwbcEntry_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlHwbcEntry_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlHwbcEntry_st>())).hwbcId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlHwbcEntry_st),
            "::",
            stringify!(hwbcId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlHwbcEntry_st>())).firmwareVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlHwbcEntry_st),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
pub type nvmlHwbcEntry_t = nvmlHwbcEntry_st;
#[doc = "!< Fan is working properly"]
pub const nvmlFanState_enum_NVML_FAN_NORMAL: nvmlFanState_enum = 0;
#[doc = "!< Fan has failed"]
pub const nvmlFanState_enum_NVML_FAN_FAILED: nvmlFanState_enum = 1;
#[doc = " Fan state enum."]
pub type nvmlFanState_enum = u32;
pub use self::nvmlFanState_enum as nvmlFanState_t;
#[doc = "!< GREEN, indicates good health"]
pub const nvmlLedColor_enum_NVML_LED_COLOR_GREEN: nvmlLedColor_enum = 0;
#[doc = "!< AMBER, indicates problem"]
pub const nvmlLedColor_enum_NVML_LED_COLOR_AMBER: nvmlLedColor_enum = 1;
#[doc = " Led color enum."]
pub type nvmlLedColor_enum = u32;
pub use self::nvmlLedColor_enum as nvmlLedColor_t;
#[doc = " LED states for an S-class unit."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlLedState_st {
    #[doc = "!< If amber, a text description of the cause"]
    pub cause: [::std::os::raw::c_char; 256usize],
    #[doc = "!< GREEN or AMBER"]
    pub color: nvmlLedColor_t,
}
#[test]
fn bindgen_test_layout_nvmlLedState_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlLedState_st>(),
        260usize,
        concat!("Size of: ", stringify!(nvmlLedState_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlLedState_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlLedState_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlLedState_st>())).cause as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlLedState_st),
            "::",
            stringify!(cause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlLedState_st>())).color as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlLedState_st),
            "::",
            stringify!(color)
        )
    );
}
pub type nvmlLedState_t = nvmlLedState_st;
#[doc = " Static S-class unit info."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlUnitInfo_st {
    #[doc = "!< Product name"]
    pub name: [::std::os::raw::c_char; 96usize],
    #[doc = "!< Product identifier"]
    pub id: [::std::os::raw::c_char; 96usize],
    #[doc = "!< Product serial number"]
    pub serial: [::std::os::raw::c_char; 96usize],
    #[doc = "!< Firmware version"]
    pub firmwareVersion: [::std::os::raw::c_char; 96usize],
}
#[test]
fn bindgen_test_layout_nvmlUnitInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUnitInfo_st>(),
        384usize,
        concat!("Size of: ", stringify!(nvmlUnitInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUnitInfo_st>(),
        1usize,
        concat!("Alignment of ", stringify!(nvmlUnitInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).serial as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitInfo_st>())).firmwareVersion as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitInfo_st),
            "::",
            stringify!(firmwareVersion)
        )
    );
}
pub type nvmlUnitInfo_t = nvmlUnitInfo_st;
#[doc = " Power usage information for an S-class unit."]
#[doc = " The power supply state is a human readable string that equals \"Normal\" or contains"]
#[doc = " a combination of \"Abnormal\" plus one or more of the following:"]
#[doc = ""]
#[doc = "    - High voltage"]
#[doc = "    - Fan failure"]
#[doc = "    - Heatsink temperature"]
#[doc = "    - Current limit"]
#[doc = "    - Voltage below UV alarm threshold"]
#[doc = "    - Low-voltage"]
#[doc = "    - SI2C remote off command"]
#[doc = "    - MOD_DISABLE input"]
#[doc = "    - Short pin transition"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlPSUInfo_st {
    #[doc = "!< The power supply state"]
    pub state: [::std::os::raw::c_char; 256usize],
    #[doc = "!< PSU current (A)"]
    pub current: ::std::os::raw::c_uint,
    #[doc = "!< PSU voltage (V)"]
    pub voltage: ::std::os::raw::c_uint,
    #[doc = "!< PSU power draw (W)"]
    pub power: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlPSUInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlPSUInfo_st>(),
        268usize,
        concat!("Size of: ", stringify!(nvmlPSUInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlPSUInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlPSUInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).current as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).voltage as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(voltage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlPSUInfo_st>())).power as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlPSUInfo_st),
            "::",
            stringify!(power)
        )
    );
}
pub type nvmlPSUInfo_t = nvmlPSUInfo_st;
#[doc = " Fan speed reading for a single fan in an S-class unit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanInfo_st {
    #[doc = "!< Fan speed (RPM)"]
    pub speed: ::std::os::raw::c_uint,
    #[doc = "!< Flag that indicates whether fan is working properly"]
    pub state: nvmlFanState_t,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUnitFanInfo_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlUnitFanInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUnitFanInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlUnitFanInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanInfo_st>())).speed as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanInfo_st),
            "::",
            stringify!(speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanInfo_st>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanInfo_st),
            "::",
            stringify!(state)
        )
    );
}
pub type nvmlUnitFanInfo_t = nvmlUnitFanInfo_st;
#[doc = " Fan speed readings for an entire S-class unit."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlUnitFanSpeeds_st {
    #[doc = "!< Fan speed data for each fan"]
    pub fans: [nvmlUnitFanInfo_t; 24usize],
    #[doc = "!< Number of fans in unit"]
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlUnitFanSpeeds_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlUnitFanSpeeds_st>(),
        196usize,
        concat!("Size of: ", stringify!(nvmlUnitFanSpeeds_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlUnitFanSpeeds_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlUnitFanSpeeds_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanSpeeds_st>())).fans as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanSpeeds_st),
            "::",
            stringify!(fans)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlUnitFanSpeeds_st>())).count as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlUnitFanSpeeds_st),
            "::",
            stringify!(count)
        )
    );
}
pub type nvmlUnitFanSpeeds_t = nvmlUnitFanSpeeds_st;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventSet_st {
    _unused: [u8; 0],
}
#[doc = " Handle to an event set"]
pub type nvmlEventSet_t = *mut nvmlEventSet_st;
#[doc = " Information about occurred event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEventData_st {
    #[doc = "!< Specific device where the event occurred"]
    pub device: nvmlDevice_t,
    #[doc = "!< Information about what specific event occurred"]
    pub eventType: ::std::os::raw::c_ulonglong,
    #[doc = "!< Stores last XID error for the device in the event of nvmlEventTypeXidCriticalError,"]
    pub eventData: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_nvmlEventData_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlEventData_st>(),
        24usize,
        concat!("Size of: ", stringify!(nvmlEventData_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlEventData_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlEventData_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).eventType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(eventType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEventData_st>())).eventData as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEventData_st),
            "::",
            stringify!(eventData)
        )
    );
}
pub type nvmlEventData_t = nvmlEventData_st;
#[doc = " Describes accounting statistics of a process."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlAccountingStats_st {
    #[doc = "!< Percent of time over the process's lifetime during which one or more kernels was executing on the GPU."]
    pub gpuUtilization: ::std::os::raw::c_uint,
    #[doc = "!< Percent of time over the process's lifetime during which global (device) memory was being read or written."]
    pub memoryUtilization: ::std::os::raw::c_uint,
    #[doc = "!< Maximum total memory in bytes that was ever allocated by the process."]
    pub maxMemoryUsage: ::std::os::raw::c_ulonglong,
    #[doc = "!< Amount of time in ms during which the compute context was active. The time is reported as 0 if"]
    #[doc = "!< the process is not terminated"]
    pub time: ::std::os::raw::c_ulonglong,
    #[doc = "!< CPU Timestamp in usec representing start time for the process"]
    pub startTime: ::std::os::raw::c_ulonglong,
    #[doc = "!< Flag to represent if the process is running (1 for running, 0 for terminated)"]
    pub isRunning: ::std::os::raw::c_uint,
    #[doc = "!< Reserved for future use"]
    pub reserved: [::std::os::raw::c_uint; 5usize],
}
#[test]
fn bindgen_test_layout_nvmlAccountingStats_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlAccountingStats_st>(),
        56usize,
        concat!("Size of: ", stringify!(nvmlAccountingStats_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlAccountingStats_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlAccountingStats_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).gpuUtilization as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(gpuUtilization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).memoryUtilization as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(memoryUtilization)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).maxMemoryUsage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(maxMemoryUsage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlAccountingStats_st>())).time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).startTime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(startTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlAccountingStats_st>())).isRunning as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(isRunning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlAccountingStats_st>())).reserved as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlAccountingStats_st),
            "::",
            stringify!(reserved)
        )
    );
}
pub type nvmlAccountingStats_t = nvmlAccountingStats_st;
#[doc = "!< VM ID represents DOMAIN ID"]
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_DOMAIN_ID: nvmlVgpuVmIdType = 0;
#[doc = "!< VM ID represents UUID"]
pub const nvmlVgpuVmIdType_NVML_VGPU_VM_ID_UUID: nvmlVgpuVmIdType = 1;
#[doc = " Types of VM identifiers"]
pub type nvmlVgpuVmIdType = u32;
pub use self::nvmlVgpuVmIdType as nvmlVgpuVmIdType_t;
#[doc = "!< Guest-dependent fields uninitialized"]
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_UNINITIALIZED:
    nvmlVgpuGuestInfoState_enum = 0;
#[doc = "!< Guest-dependent fields initialized"]
pub const nvmlVgpuGuestInfoState_enum_NVML_VGPU_INSTANCE_GUEST_INFO_STATE_INITIALIZED:
    nvmlVgpuGuestInfoState_enum = 1;
#[doc = " vGPU GUEST info state."]
pub type nvmlVgpuGuestInfoState_enum = u32;
pub use self::nvmlVgpuGuestInfoState_enum as nvmlVgpuGuestInfoState_t;
#[doc = "!< Virtual GPU"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VGPU:
    nvmlGridLicenseFeatureCode_t = 1;
#[doc = "!< Virtual Workstation"]
pub const nvmlGridLicenseFeatureCode_t_NVML_GRID_LICENSE_FEATURE_CODE_VWORKSTATION:
    nvmlGridLicenseFeatureCode_t = 2;
#[doc = " GRID license feature code"]
pub type nvmlGridLicenseFeatureCode_t = u32;
#[doc = "  @{"]
pub type nvmlVgpuTypeId_t = ::std::os::raw::c_uint;
pub type nvmlVgpuInstance_t = ::std::os::raw::c_uint;
#[doc = " Structure to store Utilization Value and vgpuInstance"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuInstanceUtilizationSample_st {
    #[doc = "!< vGPU Instance"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< SM (3D/Compute) Util Value"]
    pub smUtil: nvmlValue_t,
    #[doc = "!< Frame Buffer Memory Util Value"]
    pub memUtil: nvmlValue_t,
    #[doc = "!< Encoder Util Value"]
    pub encUtil: nvmlValue_t,
    #[doc = "!< Decoder Util Value"]
    pub decUtil: nvmlValue_t,
}
#[test]
fn bindgen_test_layout_nvmlVgpuInstanceUtilizationSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuInstanceUtilizationSample_st>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuInstanceUtilizationSample_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).vgpuInstance
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).timeStamp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).smUtil as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(smUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).memUtil as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(memUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).encUtil as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(encUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuInstanceUtilizationSample_st>())).decUtil as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuInstanceUtilizationSample_st),
            "::",
            stringify!(decUtil)
        )
    );
}
pub type nvmlVgpuInstanceUtilizationSample_t = nvmlVgpuInstanceUtilizationSample_st;
#[doc = " Structure to store Utilization Value, vgpuInstance and subprocess information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuProcessUtilizationSample_st {
    #[doc = "!< vGPU Instance"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< PID of process running within the vGPU VM"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Name of process running within the vGPU VM"]
    pub processName: [::std::os::raw::c_char; 64usize],
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< SM (3D/Compute) Util Value"]
    pub smUtil: ::std::os::raw::c_uint,
    #[doc = "!< Frame Buffer Memory Util Value"]
    pub memUtil: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Util Value"]
    pub encUtil: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Util Value"]
    pub decUtil: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlVgpuProcessUtilizationSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuProcessUtilizationSample_st>(),
        96usize,
        concat!("Size of: ", stringify!(nvmlVgpuProcessUtilizationSample_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuProcessUtilizationSample_st>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(nvmlVgpuProcessUtilizationSample_st)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).vgpuInstance as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).pid as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).processName as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(processName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).timeStamp as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).smUtil as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(smUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).memUtil as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(memUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).encUtil as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(encUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuProcessUtilizationSample_st>())).decUtil as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuProcessUtilizationSample_st),
            "::",
            stringify!(decUtil)
        )
    );
}
pub type nvmlVgpuProcessUtilizationSample_t = nvmlVgpuProcessUtilizationSample_st;
#[doc = " Structure to store utilization value and process Id"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlProcessUtilizationSample_st {
    #[doc = "!< PID of process"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< CPU Timestamp in microseconds"]
    pub timeStamp: ::std::os::raw::c_ulonglong,
    #[doc = "!< SM (3D/Compute) Util Value"]
    pub smUtil: ::std::os::raw::c_uint,
    #[doc = "!< Frame Buffer Memory Util Value"]
    pub memUtil: ::std::os::raw::c_uint,
    #[doc = "!< Encoder Util Value"]
    pub encUtil: ::std::os::raw::c_uint,
    #[doc = "!< Decoder Util Value"]
    pub decUtil: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlProcessUtilizationSample_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlProcessUtilizationSample_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlProcessUtilizationSample_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlProcessUtilizationSample_st>(),
        8usize,
        concat!("Alignment of ", stringify!(nvmlProcessUtilizationSample_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).pid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).timeStamp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(timeStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).smUtil as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(smUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).memUtil as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(memUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).encUtil as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(encUtil)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlProcessUtilizationSample_st>())).decUtil as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlProcessUtilizationSample_st),
            "::",
            stringify!(decUtil)
        )
    );
}
pub type nvmlProcessUtilizationSample_t = nvmlProcessUtilizationSample_st;
#[doc = " Structure containing GRID licensable feature information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeature_st {
    #[doc = "!< Licensed feature code"]
    pub featureCode: nvmlGridLicenseFeatureCode_t,
    #[doc = "!< Non-zero if feature is currently licensed, otherwise zero"]
    pub featureState: ::std::os::raw::c_uint,
    pub licenseInfo: [::std::os::raw::c_char; 128usize],
    pub productName: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_nvmlGridLicensableFeature_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGridLicensableFeature_st>(),
        264usize,
        concat!("Size of: ", stringify!(nvmlGridLicensableFeature_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGridLicensableFeature_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlGridLicensableFeature_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).featureCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(featureCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).featureState as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(featureState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).licenseInfo as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(licenseInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeature_st>())).productName as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeature_st),
            "::",
            stringify!(productName)
        )
    );
}
pub type nvmlGridLicensableFeature_t = nvmlGridLicensableFeature_st;
#[doc = " Structure to store GRID licensable features"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlGridLicensableFeatures_st {
    #[doc = "!< Non-zero if GRID Software Licensing is supported on the system, otherwise zero"]
    pub isGridLicenseSupported: ::std::os::raw::c_int,
    #[doc = "!< Entries returned in \\a gridLicensableFeatures array"]
    pub licensableFeaturesCount: ::std::os::raw::c_uint,
    #[doc = "!< Array of GRID licensable features."]
    pub gridLicensableFeatures: [nvmlGridLicensableFeature_t; 3usize],
}
#[test]
fn bindgen_test_layout_nvmlGridLicensableFeatures_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlGridLicensableFeatures_st>(),
        800usize,
        concat!("Size of: ", stringify!(nvmlGridLicensableFeatures_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlGridLicensableFeatures_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlGridLicensableFeatures_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeatures_st>())).isGridLicenseSupported
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeatures_st),
            "::",
            stringify!(isGridLicenseSupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeatures_st>())).licensableFeaturesCount
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeatures_st),
            "::",
            stringify!(licensableFeaturesCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlGridLicensableFeatures_st>())).gridLicensableFeatures
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlGridLicensableFeatures_st),
            "::",
            stringify!(gridLicensableFeatures)
        )
    );
}
pub type nvmlGridLicensableFeatures_t = nvmlGridLicensableFeatures_st;
#[doc = "!< H264 encoder"]
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_H264: nvmlEncoderQueryType_enum = 0;
#[doc = "!< HEVC encoder"]
pub const nvmlEncoderQueryType_enum_NVML_ENCODER_QUERY_HEVC: nvmlEncoderQueryType_enum = 1;
#[doc = " Represents type of encoder for capacity can be queried"]
pub type nvmlEncoderQueryType_enum = u32;
pub use self::nvmlEncoderQueryType_enum as nvmlEncoderType_t;
#[doc = " Structure to hold encoder session data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlEncoderSessionInfo_st {
    #[doc = "!< Unique session ID"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "!< Owning process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Owning vGPU instance ID (only valid on vGPU hosts, otherwise zero)"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< Video encoder type"]
    pub codecType: nvmlEncoderType_t,
    #[doc = "!< Current encode horizontal resolution"]
    pub hResolution: ::std::os::raw::c_uint,
    #[doc = "!< Current encode vertical resolution"]
    pub vResolution: ::std::os::raw::c_uint,
    #[doc = "!< Moving average encode frames per second"]
    pub averageFps: ::std::os::raw::c_uint,
    #[doc = "!< Moving average encode latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlEncoderSessionInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlEncoderSessionInfo_st>(),
        32usize,
        concat!("Size of: ", stringify!(nvmlEncoderSessionInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlEncoderSessionInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlEncoderSessionInfo_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).sessionId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).vgpuInstance as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).codecType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(codecType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).hResolution as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(hResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).vResolution as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(vResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).averageFps as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(averageFps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlEncoderSessionInfo_st>())).averageLatency as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlEncoderSessionInfo_st),
            "::",
            stringify!(averageLatency)
        )
    );
}
pub type nvmlEncoderSessionInfo_t = nvmlEncoderSessionInfo_st;
#[doc = "!< Unknwon"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_UNKNOWN: nvmlFBCSessionType_enum = 0;
#[doc = "!< ToSys"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_TOSYS: nvmlFBCSessionType_enum = 1;
#[doc = "!< Cuda"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_CUDA: nvmlFBCSessionType_enum = 2;
#[doc = "!< Vid"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_VID: nvmlFBCSessionType_enum = 3;
#[doc = "!< HEnc"]
pub const nvmlFBCSessionType_enum_NVML_FBC_SESSION_TYPE_HWENC: nvmlFBCSessionType_enum = 4;
#[doc = " Represents frame buffer capture session type"]
pub type nvmlFBCSessionType_enum = u32;
pub use self::nvmlFBCSessionType_enum as nvmlFBCSessionType_t;
#[doc = " Structure to hold frame buffer capture sessions stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCStats_st {
    #[doc = "!< Total no of sessions"]
    pub sessionsCount: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frames captured per second"]
    pub averageFPS: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frame capture latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlFBCStats_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlFBCStats_st>(),
        12usize,
        concat!("Size of: ", stringify!(nvmlFBCStats_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlFBCStats_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlFBCStats_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCStats_st>())).sessionsCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCStats_st),
            "::",
            stringify!(sessionsCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCStats_st>())).averageFPS as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCStats_st),
            "::",
            stringify!(averageFPS)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCStats_st>())).averageLatency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCStats_st),
            "::",
            stringify!(averageLatency)
        )
    );
}
pub type nvmlFBCStats_t = nvmlFBCStats_st;
#[doc = " Structure to hold FBC session data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlFBCSessionInfo_st {
    #[doc = "!< Unique session ID"]
    pub sessionId: ::std::os::raw::c_uint,
    #[doc = "!< Owning process ID"]
    pub pid: ::std::os::raw::c_uint,
    #[doc = "!< Owning vGPU instance ID (only valid on vGPU hosts, otherwise zero)"]
    pub vgpuInstance: nvmlVgpuInstance_t,
    #[doc = "!< Display identifier"]
    pub displayOrdinal: ::std::os::raw::c_uint,
    #[doc = "!< Type of frame buffer capture session"]
    pub sessionType: nvmlFBCSessionType_t,
    #[doc = "!< Session flags (one or more of NVML_NVFBC_SESSION_FLAG_XXX)."]
    pub sessionFlags: ::std::os::raw::c_uint,
    #[doc = "!< Max horizontal resolution supported by the capture session"]
    pub hMaxResolution: ::std::os::raw::c_uint,
    #[doc = "!< Max vertical resolution supported by the capture session"]
    pub vMaxResolution: ::std::os::raw::c_uint,
    #[doc = "!< Horizontal resolution requested by caller in capture call"]
    pub hResolution: ::std::os::raw::c_uint,
    #[doc = "!< Vertical resolution requested by caller in capture call"]
    pub vResolution: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frames captured per second"]
    pub averageFPS: ::std::os::raw::c_uint,
    #[doc = "!< Moving average new frame capture latency in microseconds"]
    pub averageLatency: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlFBCSessionInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlFBCSessionInfo_st>(),
        48usize,
        concat!("Size of: ", stringify!(nvmlFBCSessionInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlFBCSessionInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlFBCSessionInfo_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).sessionId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(sessionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).pid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(pid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).vgpuInstance as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(vgpuInstance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).displayOrdinal as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(displayOrdinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).sessionType as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(sessionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).sessionFlags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(sessionFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).hMaxResolution as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(hMaxResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).vMaxResolution as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(vMaxResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).hResolution as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(hResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).vResolution as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(vResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).averageFPS as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(averageFPS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlFBCSessionInfo_st>())).averageLatency as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlFBCSessionInfo_st),
            "::",
            stringify!(averageLatency)
        )
    );
}
pub type nvmlFBCSessionInfo_t = nvmlFBCSessionInfo_st;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_KEEP: nvmlDetachGpuState_enum = 0;
pub const nvmlDetachGpuState_enum_NVML_DETACH_GPU_REMOVE: nvmlDetachGpuState_enum = 1;
#[doc = "  Is the GPU device to be removed from the kernel by nvmlDeviceRemoveGpu()"]
pub type nvmlDetachGpuState_enum = u32;
pub use self::nvmlDetachGpuState_enum as nvmlDetachGpuState_t;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_KEEP: nvmlPcieLinkState_enum = 0;
pub const nvmlPcieLinkState_enum_NVML_PCIE_LINK_SHUT_DOWN: nvmlPcieLinkState_enum = 1;
#[doc = "  Parent bridge PCIe link state requested by nvmlDeviceRemoveGpu()"]
pub type nvmlPcieLinkState_enum = u32;
pub use self::nvmlPcieLinkState_enum as nvmlPcieLinkState_t;
extern "C" {
    pub fn nvmlInit_v2() -> nvmlReturn_t;
}
extern "C" {
    #[doc = " nvmlInitWithFlags is a variant of nvmlInit(), that allows passing a set of boolean values"]
    #[doc = "       modifying the behaviour of nvmlInit()."]
    #[doc = "       Other than the \"flags\" parameter it is completely similar to \\ref nvmlInit."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " @param flags                                 behaviour modifier flags"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   if NVML has been properly initialized"]
    #[doc = "         - \\ref NVML_ERROR_DRIVER_NOT_LOADED   if NVIDIA driver is not running"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION       if NVML does not have permission to talk to the driver"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlInitWithFlags(flags: ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Shut down NVML by releasing all GPU resources previously allocated with \\ref nvmlInit()."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " This method should be called after NVML work is done, once for each call to \\ref nvmlInit()"]
    #[doc = " A reference count of the number of initializations is maintained.  Shutdown only occurs"]
    #[doc = " when the reference count reaches zero.  For backwards compatibility, no error is reported if"]
    #[doc = " nvmlShutdown() is called more times than nvmlInit()."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if NVML has been properly shut down"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlShutdown() -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Helper method for converting NVML error codes into readable strings."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " @param result                               NVML error code to convert"]
    #[doc = ""]
    #[doc = " @return String representation of the error."]
    #[doc = ""]
    pub fn nvmlErrorString(result: nvmlReturn_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Retrieves the version of the system's graphics driver."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The version identifier is an alphanumeric string.  It will not exceed 80 characters in length"]
    #[doc = " (including the NULL terminator).  See \\ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param version                              Reference in which to return the version identifier"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    pub fn nvmlSystemGetDriverVersion(
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the NVML library."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The version identifier is an alphanumeric string.  It will not exceed 80 characters in length"]
    #[doc = " (including the NULL terminator).  See \\ref nvmlConstants::NVML_SYSTEM_NVML_VERSION_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param version                              Reference in which to return the version identifier"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    pub fn nvmlSystemGetNVMLVersion(
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the CUDA driver."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The CUDA driver version returned will be retreived from the currently installed version of CUDA."]
    #[doc = " If the cuda library is not found, this function will return a known supported version number."]
    #[doc = ""]
    #[doc = " @param cudaDriverVersion                    Reference in which to return the version identifier"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a cudaDriverVersion has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a cudaDriverVersion is NULL"]
    pub fn nvmlSystemGetCudaDriverVersion(
        cudaDriverVersion: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the CUDA driver from the shared library."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The returned CUDA driver version by calling cuDriverGetVersion()"]
    #[doc = ""]
    #[doc = " @param cudaDriverVersion                    Reference in which to return the version identifier"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a cudaDriverVersion has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a cudaDriverVersion is NULL"]
    #[doc = "         - \\ref NVML_ERROR_LIBRARY_NOT_FOUND  if \\a libcuda.so.1 or libcuda.dll is not found"]
    #[doc = "         - \\ref NVML_ERROR_FUNCTION_NOT_FOUND if \\a cuDriverGetVersion() is not found in the shared library"]
    pub fn nvmlSystemGetCudaDriverVersion_v2(
        cudaDriverVersion: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets name of the process with provided process id"]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " Returned process name is cropped to provided length."]
    #[doc = " name string is encoded in ANSI."]
    #[doc = ""]
    #[doc = " @param pid                                  The identifier of the process"]
    #[doc = " @param name                                 Reference in which to return the process name"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a name"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a name has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a name is NULL or \\a length is 0."]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if process doesn't exists"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlSystemGetProcessName(
        pid: ::std::os::raw::c_uint,
        name: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the number of units in the system."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " @param unitCount                            Reference in which to return the number of units"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a unitCount has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unitCount is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetCount(unitCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular unit, based on its index."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " Valid indices are derived from the \\a unitCount returned by \\ref nvmlUnitGetCount()."]
    #[doc = "   For example, if \\a unitCount is 2 the valid indices are 0 and 1, corresponding to UNIT 0 and UNIT 1."]
    #[doc = ""]
    #[doc = " The order in which NVML enumerates units has no guarantees of consistency between reboots."]
    #[doc = ""]
    #[doc = " @param index                                The index of the target unit, >= 0 and < \\a unitCount"]
    #[doc = " @param unit                                 Reference in which to return the unit handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a unit has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a index is invalid or \\a unit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetHandleByIndex(
        index: ::std::os::raw::c_uint,
        unit: *mut nvmlUnit_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the static information associated with a unit."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " See \\ref nvmlUnitInfo_t for details on available unit info."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param info                                 Reference in which to return the unit information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a info has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a info is NULL"]
    pub fn nvmlUnitGetUnitInfo(unit: nvmlUnit_t, info: *mut nvmlUnitInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the LED state associated with this unit."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " See \\ref nvmlLedState_t for details on allowed states."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param state                                Reference in which to return the current LED state"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a state has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a state is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlUnitSetLedState()"]
    pub fn nvmlUnitGetLedState(unit: nvmlUnit_t, state: *mut nvmlLedState_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the PSU stats for the unit."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " See \\ref nvmlPSUInfo_t for details on available PSU info."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param psu                                  Reference in which to return the PSU information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a psu has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a psu is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetPsuInfo(unit: nvmlUnit_t, psu: *mut nvmlPSUInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the temperature readings for the unit, in degrees C."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " Depending on the product, readings may be available for intake (type=0),"]
    #[doc = " exhaust (type=1) and board (type=2)."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param type                                 The type of reading to take"]
    #[doc = " @param temp                                 Reference in which to return the intake temperature"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a temp has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit or \\a type is invalid or \\a temp is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetTemperature(
        unit: nvmlUnit_t,
        type_: ::std::os::raw::c_uint,
        temp: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the fan speed readings for the unit."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " See \\ref nvmlUnitFanSpeeds_t for details on available fan speed info."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param fanSpeeds                            Reference in which to return the fan speed information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a fanSpeeds has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid or \\a fanSpeeds is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetFanSpeedInfo(
        unit: nvmlUnit_t,
        fanSpeeds: *mut nvmlUnitFanSpeeds_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the set of GPU devices that are attached to the specified unit."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " The \\a deviceCount argument is expected to be set to the size of the input \\a devices array."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param deviceCount                          Reference in which to provide the \\a devices array size, and"]
    #[doc = "                                             to return the number of attached GPU devices"]
    #[doc = " @param devices                              Reference in which to return the references to the attached GPU devices"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a deviceCount and \\a devices have been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a deviceCount indicates that the \\a devices array is too small"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit is invalid, either of \\a deviceCount or \\a devices is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlUnitGetDevices(
        unit: nvmlUnit_t,
        deviceCount: *mut ::std::os::raw::c_uint,
        devices: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the IDs and firmware versions for any Host Interface Cards (HICs) in the system."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = ""]
    #[doc = " The \\a hwbcCount argument is expected to be set to the size of the input \\a hwbcEntries array."]
    #[doc = " The HIC must be connected to an S-class system for it to be reported by this function."]
    #[doc = ""]
    #[doc = " @param hwbcCount                            Size of hwbcEntries array"]
    #[doc = " @param hwbcEntries                          Array holding information about hwbc"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a hwbcCount and \\a hwbcEntries have been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if either \\a hwbcCount or \\a hwbcEntries is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a hwbcCount indicates that the \\a hwbcEntries array is too small"]
    pub fn nvmlSystemGetHicVersion(
        hwbcCount: *mut ::std::os::raw::c_uint,
        hwbcEntries: *mut nvmlHwbcEntry_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetCount_v2(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByIndex_v2(
        index: ::std::os::raw::c_uint,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular device, based on its board serial number."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " This number corresponds to the value printed directly on the board, and to the value returned by"]
    #[doc = "   \\ref nvmlDeviceGetSerial()."]
    #[doc = ""]
    #[doc = " @deprecated Since more than one GPU can exist on a single board this function is deprecated in favor"]
    #[doc = "             of \\ref nvmlDeviceGetHandleByUUID."]
    #[doc = "             For dual GPU boards this function will return NVML_ERROR_INVALID_ARGUMENT."]
    #[doc = ""]
    #[doc = " Starting from NVML 5, this API causes NVML to initialize the target GPU"]
    #[doc = " NVML may initialize additional GPUs as it searches for the target GPU"]
    #[doc = ""]
    #[doc = " @param serial                               The board serial number of the target GPU"]
    #[doc = " @param device                               Reference in which to return the device handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a device has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a serial is invalid, \\a device is NULL or more than one"]
    #[doc = "                                              device has the same serial (dual GPU boards)"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND          if \\a serial does not match a valid device on the system"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables"]
    #[doc = "         - \\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetSerial"]
    #[doc = " @see nvmlDeviceGetHandleByUUID"]
    pub fn nvmlDeviceGetHandleBySerial(
        serial: *const ::std::os::raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the handle for a particular device, based on its globally unique immutable UUID associated with each device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " @param uuid                                 The UUID of the target GPU"]
    #[doc = " @param device                               Reference in which to return the device handle"]
    #[doc = ""]
    #[doc = " Starting from NVML 5, this API causes NVML to initialize the target GPU"]
    #[doc = " NVML may initialize additional GPUs as it searches for the target GPU"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a device has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a uuid is invalid or \\a device is null"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND          if \\a uuid does not match a valid device on the system"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_POWER if any attached devices have improperly attached external power cables"]
    #[doc = "         - \\ref NVML_ERROR_IRQ_ISSUE          if NVIDIA kernel detected an interrupt issue with the attached GPUs"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if any GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetUUID"]
    pub fn nvmlDeviceGetHandleByUUID(
        uuid: *const ::std::os::raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetHandleByPciBusId_v2(
        pciBusId: *const ::std::os::raw::c_char,
        device: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the name of this device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The name is an alphanumeric string that denotes a particular product, e.g. Tesla &tm; C2070. It will not"]
    #[doc = " exceed 64 characters in length (including the NULL terminator).  See \\ref"]
    #[doc = " nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param name                                 Reference in which to return the product name"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a name"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a name has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a name is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetName(
        device: nvmlDevice_t,
        name: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the brand of this device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The type is a member of \\ref nvmlBrandType_t defined above."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param type                                 Reference in which to return the product brand type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a name has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a type is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetBrand(device: nvmlDevice_t, type_: *mut nvmlBrandType_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the NVML index of this device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " Valid indices are derived from the \\a accessibleDevices count returned by"]
    #[doc = "   \\ref nvmlDeviceGetCount(). For example, if \\a accessibleDevices is 2 the valid indices"]
    #[doc = "   are 0 and 1, corresponding to GPU 0 and GPU 1."]
    #[doc = ""]
    #[doc = " The order in which NVML enumerates devices has no guarantees of consistency between reboots. For that reason it"]
    #[doc = "   is recommended that devices be looked up by their PCI ids or GPU UUID. See"]
    #[doc = "   \\ref nvmlDeviceGetHandleByPciBusId() and \\ref nvmlDeviceGetHandleByUUID()."]
    #[doc = ""]
    #[doc = " Note: The NVML index may not correlate with other APIs, such as the CUDA device index."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param index                                Reference in which to return the NVML index of the device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a index has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a index is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetHandleByIndex()"]
    #[doc = " @see nvmlDeviceGetCount()"]
    pub fn nvmlDeviceGetIndex(
        device: nvmlDevice_t,
        index: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the globally unique board serial number associated with this device's board."]
    #[doc = ""]
    #[doc = " For all products with an inforom."]
    #[doc = ""]
    #[doc = " The serial number is an alphanumeric string that will not exceed 30 characters (including the NULL terminator)."]
    #[doc = " This number matches the serial number tag that is physically attached to the board.  See \\ref"]
    #[doc = " nvmlConstants::NVML_DEVICE_SERIAL_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param serial                               Reference in which to return the board/module serial number"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a serial"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a serial has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a serial is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetSerial(
        device: nvmlDevice_t,
        serial: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves an array of unsigned ints (sized to cpuSetSize) of bitmasks with the ideal CPU affinity for the device"]
    #[doc = " For example, if processors 0, 1, 32, and 33 are ideal for the device and cpuSetSize == 2,"]
    #[doc = "     result[0] = 0x3, result[1] = 0x3"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Supported on Linux only."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param cpuSetSize                           The size of the cpuSet array that is safe to access"]
    #[doc = " @param cpuSet                               Array reference in which to return a bitmask of CPUs, 64 CPUs per"]
    #[doc = "                                                 unsigned long on 64-bit machines, 32 on 32-bit machines"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a cpuAffinity has been filled"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, cpuSetSize == 0, or cpuSet is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCpuAffinity(
        device: nvmlDevice_t,
        cpuSetSize: ::std::os::raw::c_uint,
        cpuSet: *mut ::std::os::raw::c_ulong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets the ideal affinity for the calling thread and device using the guidelines"]
    #[doc = " given in nvmlDeviceGetCpuAffinity().  Note, this is a change as of version 8.0."]
    #[doc = " Older versions set the affinity for a calling process and all children."]
    #[doc = " Currently supports up to 64 processors."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Supported on Linux only."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the calling process has been successfully bound"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clear all affinity bindings for the calling thread.  Note, this is a change as of version"]
    #[doc = " 8.0 as older versions cleared the affinity for a calling process and all children."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Supported on Linux only."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the calling process has been successfully unbound"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceClearCpuAffinity(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the common ancestor for two devices"]
    #[doc = " For all products."]
    #[doc = " Supported on Linux only."]
    #[doc = ""]
    #[doc = " @param device1                              The identifier of the first device"]
    #[doc = " @param device2                              The identifier of the second device"]
    #[doc = " @param pathInfo                             A \\ref nvmlGpuTopologyLevel_t that gives the path type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a pathInfo has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device1, or \\a device2 is invalid, or \\a pathInfo is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery"]
    pub fn nvmlDeviceGetTopologyCommonAncestor(
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        pathInfo: *mut nvmlGpuTopologyLevel_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the set of GPUs that are nearest to a given device at a specific interconnectivity level"]
    #[doc = " For all products."]
    #[doc = " Supported on Linux only."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the first device"]
    #[doc = " @param level                                The \\ref nvmlGpuTopologyLevel_t level to search for other GPUs"]
    #[doc = " @param count                                When zero, is set to the number of matching GPUs such that \\a deviceArray"]
    #[doc = "                                             can be malloc'd.  When non-zero, \\a deviceArray will be filled with \\a count"]
    #[doc = "                                             number of device handles."]
    #[doc = " @param deviceArray                          An array of device handles for GPUs found at \\a level"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a deviceArray or \\a count (if initially zero) has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a level, or \\a count is invalid, or \\a deviceArray is NULL with a non-zero \\a count"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery"]
    pub fn nvmlDeviceGetTopologyNearestGpus(
        device: nvmlDevice_t,
        level: nvmlGpuTopologyLevel_t,
        count: *mut ::std::os::raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the set of GPUs that have a CPU affinity with the given CPU number"]
    #[doc = " For all products."]
    #[doc = " Supported on Linux only."]
    #[doc = ""]
    #[doc = " @param cpuNumber                            The CPU number"]
    #[doc = " @param count                                When zero, is set to the number of matching GPUs such that \\a deviceArray"]
    #[doc = "                                             can be malloc'd.  When non-zero, \\a deviceArray will be filled with \\a count"]
    #[doc = "                                             number of device handles."]
    #[doc = " @param deviceArray                          An array of device handles for GPUs found with affinity to \\a cpuNumber"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a deviceArray or \\a count (if initially zero) has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a cpuNumber, or \\a count is invalid, or \\a deviceArray is NULL with a non-zero \\a count"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or OS does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           an error has occurred in underlying topology discovery"]
    pub fn nvmlSystemGetTopologyGpuSet(
        cpuNumber: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
        deviceArray: *mut nvmlDevice_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the status for a given p2p capability index between a given pair of GPU"]
    #[doc = ""]
    #[doc = " @param device1                              The first device"]
    #[doc = " @param device2                              The second device"]
    #[doc = " @param p2pIndex                             p2p Capability Index being looked for between \\a device1 and \\a device2"]
    #[doc = " @param p2pStatus                            Reference in which to return the status of the \\a p2pIndex"]
    #[doc = "                                             between \\a device1 and \\a device2"]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS         if \\a p2pStatus has been populated"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT     if \\a device1 or \\a device2 or \\a p2pIndex is invalid or \\a p2pStatus is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN              on any unexpected error"]
    pub fn nvmlDeviceGetP2PStatus(
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        p2pIndex: nvmlGpuP2PCapsIndex_t,
        p2pStatus: *mut nvmlGpuP2PStatus_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the globally unique immutable UUID associated with this device, as a 5 part hexadecimal string,"]
    #[doc = " that augments the immutable, board serial identifier."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The UUID is a globally unique identifier. It is the only available identifier for pre-Fermi-architecture products."]
    #[doc = " It does NOT correspond to any identifier printed on the board.  It will not exceed 80 characters in length"]
    #[doc = " (including the NULL terminator).  See \\ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param uuid                                 Reference in which to return the GPU UUID"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a uuid"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a uuid has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a uuid is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetUUID(
        device: nvmlDevice_t,
        uuid: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves minor number for the device. The minor number for the device is such that the Nvidia device node file for"]
    #[doc = " each GPU will have the form /dev/nvidia[minor number]."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = " Supported only for Linux"]
    #[doc = ""]
    #[doc = " @param device                                The identifier of the target device"]
    #[doc = " @param minorNumber                           Reference in which to return the minor number for the device"]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the minor number is successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minorNumber is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMinorNumber(
        device: nvmlDevice_t,
        minorNumber: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the the device board part number which is programmed into the board's InfoROM"]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " @param device                                Identifier of the target device"]
    #[doc = " @param partNumber                            Reference to the buffer to return"]
    #[doc = " @param length                                Length of the buffer reference"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a partNumber has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED      if the needed VBIOS fields have not been filled"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid or \\a serial is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetBoardPartNumber(
        device: nvmlDevice_t,
        partNumber: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version information for the device's infoROM object."]
    #[doc = ""]
    #[doc = " For all products with an inforom."]
    #[doc = ""]
    #[doc = " Fermi and higher parts have non-volatile on-board memory for persisting device info, such as aggregate"]
    #[doc = " ECC counts. The version of the data structures in this memory may change from time to time. It will not"]
    #[doc = " exceed 16 characters in length (including the NULL terminator)."]
    #[doc = " See \\ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " See \\ref nvmlInforomObject_t for details on the available infoROM objects."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param object                               The target infoROM object"]
    #[doc = " @param version                              Reference in which to return the infoROM version"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetInforomImageVersion"]
    pub fn nvmlDeviceGetInforomVersion(
        device: nvmlDevice_t,
        object: nvmlInforomObject_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the global infoROM image version"]
    #[doc = ""]
    #[doc = " For all products with an inforom."]
    #[doc = ""]
    #[doc = " Image version just like VBIOS version uniquely describes the exact version of the infoROM flashed on the board"]
    #[doc = " in contrast to infoROM object version which is only an indicator of supported features."]
    #[doc = " Version string will not exceed 16 characters in length (including the NULL terminator)."]
    #[doc = " See \\ref nvmlConstants::NVML_DEVICE_INFOROM_VERSION_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param version                              Reference in which to return the infoROM image version"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a version is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have an infoROM"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetInforomVersion"]
    pub fn nvmlDeviceGetInforomImageVersion(
        device: nvmlDevice_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the checksum of the configuration stored in the device's infoROM."]
    #[doc = ""]
    #[doc = " For all products with an inforom."]
    #[doc = ""]
    #[doc = " Can be used to make sure that two GPUs have the exact same configuration."]
    #[doc = " Current checksum takes into account configuration stored in PWR and ECC infoROM objects."]
    #[doc = " Checksum can change between driver releases or when user changes configuration (e.g. disable/enable ECC)"]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param checksum                             Reference in which to return the infoROM configuration checksum"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a checksum has been set"]
    #[doc = "         - \\ref NVML_ERROR_CORRUPTED_INFOROM if the device's checksum couldn't be retrieved due to infoROM corruption"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a checksum is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetInforomConfigurationChecksum(
        device: nvmlDevice_t,
        checksum: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Reads the infoROM from the flash and verifies the checksums."]
    #[doc = ""]
    #[doc = " For all products with an inforom."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if infoROM is not corrupted"]
    #[doc = "         - \\ref NVML_ERROR_CORRUPTED_INFOROM if the device's infoROM is corrupted"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceValidateInforom(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the display mode for the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " This method indicates whether a physical display (e.g. monitor) is currently connected to"]
    #[doc = " any of the device's connectors."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for details on allowed modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param display                              Reference in which to return the display mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a display has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a display is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDisplayMode(
        device: nvmlDevice_t,
        display: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the display active state for the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " This method indicates whether a display is initialized on the device."]
    #[doc = " For example whether X Server is attached to this device and has allocated memory for the screen."]
    #[doc = ""]
    #[doc = " Display can be active even when no monitor is physically attached."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for details on allowed modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param isActive                             Reference in which to return the display active state"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a isActive has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a isActive is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDisplayActive(
        device: nvmlDevice_t,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the persistence mode associated with this device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = " For Linux only."]
    #[doc = ""]
    #[doc = " When driver persistence mode is enabled the driver software state is not torn down when the last"]
    #[doc = " client disconnects. By default this feature is disabled."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for details on allowed modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 Reference in which to return the current driver persistence mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a mode has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetPersistenceMode()"]
    pub fn nvmlDeviceGetPersistenceMode(
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetPciInfo_v3(device: nvmlDevice_t, pci: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the maximum PCIe link generation possible with this device and system"]
    #[doc = ""]
    #[doc = " I.E. for a generation 2 PCIe device attached to a generation 1 PCIe bus the max link generation this function will"]
    #[doc = " report is generation 1."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param maxLinkGen                           Reference in which to return the max PCIe link generation"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a maxLinkGen has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a maxLinkGen is null"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxPcieLinkGeneration(
        device: nvmlDevice_t,
        maxLinkGen: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the maximum PCIe link width possible with this device and system"]
    #[doc = ""]
    #[doc = " I.E. for a device with a 16x PCIe bus width attached to a 8x PCIe system bus this function will report"]
    #[doc = " a max link width of 8."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param maxLinkWidth                         Reference in which to return the max PCIe link generation"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a maxLinkWidth has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a maxLinkWidth is null"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxPcieLinkWidth(
        device: nvmlDevice_t,
        maxLinkWidth: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current PCIe link generation"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param currLinkGen                          Reference in which to return the current PCIe link generation"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a currLinkGen has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a currLinkGen is null"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCurrPcieLinkGeneration(
        device: nvmlDevice_t,
        currLinkGen: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current PCIe link width"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param currLinkWidth                        Reference in which to return the current PCIe link generation"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a currLinkWidth has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a currLinkWidth is null"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if PCIe link information is not available"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCurrPcieLinkWidth(
        device: nvmlDevice_t,
        currLinkWidth: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve PCIe utilization information."]
    #[doc = " This function is querying a byte counter over a 20ms interval and thus is the"]
    #[doc = "   PCIe throughput over that interval."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " This method is not supported in virtual machines running virtual GPU (vGPU)."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param counter                              The specific counter that should be queried \\ref nvmlPcieUtilCounter_t"]
    #[doc = " @param value                                Reference in which to return throughput in KB/s"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a value has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a counter is invalid, or \\a value is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPcieThroughput(
        device: nvmlDevice_t,
        counter: nvmlPcieUtilCounter_t,
        value: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the PCIe replay counter."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param value                                Reference in which to return the counter's value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a value has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a value is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPcieReplayCounter(
        device: nvmlDevice_t,
        value: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current clock speeds for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlClockType_t for details on available clock information."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param type                                 Identify which clock domain to query"]
    #[doc = " @param clock                                Reference in which to return the clock speed in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clock has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clock is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetClockInfo(
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the maximum clock speeds for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlClockType_t for details on available clock information."]
    #[doc = ""]
    #[doc = " \\note On GPUs from Fermi family current P0 clocks (reported by \\ref nvmlDeviceGetClockInfo) can differ from max clocks"]
    #[doc = "       by few MHz."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param type                                 Identify which clock domain to query"]
    #[doc = " @param clock                                Reference in which to return the clock speed in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clock has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clock is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device cannot report the specified clock"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxClockInfo(
        device: nvmlDevice_t,
        type_: nvmlClockType_t,
        clock: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current setting of a clock that applications will use unless an overspec situation occurs."]
    #[doc = " Can be changed using \\ref nvmlDeviceSetApplicationsClocks."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param clockType                            Identify which clock domain to query"]
    #[doc = " @param clockMHz                             Reference in which to return the clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetApplicationsClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the default applications clock that GPU boots with or"]
    #[doc = " defaults to after \\ref nvmlDeviceResetApplicationsClocks call."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param clockType                            Identify which clock domain to query"]
    #[doc = " @param clockMHz                             Reference in which to return the default clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " \\see nvmlDeviceGetApplicationsClock"]
    pub fn nvmlDeviceGetDefaultApplicationsClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets the application clock to the default value"]
    #[doc = ""]
    #[doc = " This is the applications clock that will be used after system reboot or driver reload."]
    #[doc = " Default value is constant, but the current value an be changed using \\ref nvmlDeviceSetApplicationsClocks."]
    #[doc = ""]
    #[doc = " On Pascal and newer hardware, if clocks were previously locked with \\ref nvmlDeviceSetApplicationsClocks,"]
    #[doc = " this call will unlock clocks. This returns clocks their default behavior ofautomatically boosting above"]
    #[doc = " base clocks as thermal limits allow."]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetApplicationsClock"]
    #[doc = " @see nvmlDeviceSetApplicationsClocks"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if new settings were successfully set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetApplicationsClocks(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the clock speed for the clock specified by the clock type and clock ID."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param clockType                            Identify which clock domain to query"]
    #[doc = " @param clockId                              Identify which clock in the domain to query"]
    #[doc = " @param clockMHz                             Reference in which to return the clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockId: nvmlClockId_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the customer defined maximum boost clock speed specified by the given clock type."]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param clockType                            Identify which clock domain to query"]
    #[doc = " @param clockMHz                             Reference in which to return the clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clockMHz has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clockMHz is NULL or \\a clockType is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device or the \\a clockType on this device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMaxCustomerBoostClock(
        device: nvmlDevice_t,
        clockType: nvmlClockType_t,
        clockMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the list of possible memory clocks that can be used as an argument for \\ref nvmlDeviceSetApplicationsClocks."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param count                                Reference in which to provide the \\a clocksMHz array size, and"]
    #[doc = "                                             to return the number of elements"]
    #[doc = " @param clocksMHz                            Reference in which to return the clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a count and \\a clocksMHz have been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a count is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small (\\a count is set to the number of"]
    #[doc = "                                                required elements)"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetApplicationsClocks"]
    #[doc = " @see nvmlDeviceGetSupportedGraphicsClocks"]
    pub fn nvmlDeviceGetSupportedMemoryClocks(
        device: nvmlDevice_t,
        count: *mut ::std::os::raw::c_uint,
        clocksMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the list of possible graphics clocks that can be used as an argument for \\ref nvmlDeviceSetApplicationsClocks."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param memoryClockMHz                       Memory clock for which to return possible graphics clocks"]
    #[doc = " @param count                                Reference in which to provide the \\a clocksMHz array size, and"]
    #[doc = "                                             to return the number of elements"]
    #[doc = " @param clocksMHz                            Reference in which to return the clocks in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a count and \\a clocksMHz have been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if the specified \\a memoryClockMHz is not a supported frequency"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clock is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetApplicationsClocks"]
    #[doc = " @see nvmlDeviceGetSupportedMemoryClocks"]
    pub fn nvmlDeviceGetSupportedGraphicsClocks(
        device: nvmlDevice_t,
        memoryClockMHz: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
        clocksMHz: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the current state of Auto Boosted clocks on a device and store it in \\a isEnabled"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates"]
    #[doc = " to maximize performance as thermal limits allow."]
    #[doc = ""]
    #[doc = " On Pascal and newer hardware, Auto Aoosted clocks are controlled through application clocks."]
    #[doc = " Use \\ref nvmlDeviceSetApplicationsClocks and \\ref nvmlDeviceResetApplicationsClocks to control Auto Boost"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param isEnabled                            Where to store the current state of Auto Boosted clocks of the target device"]
    #[doc = " @param defaultIsEnabled                     Where to store the default Auto Boosted clocks behavior of the target device that the device will"]
    #[doc = "                                                 revert to when no applications are using the GPU"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 If \\a isEnabled has been been set with the Auto Boosted clocks state of \\a device"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a isEnabled is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    pub fn nvmlDeviceGetAutoBoostedClocksEnabled(
        device: nvmlDevice_t,
        isEnabled: *mut nvmlEnableState_t,
        defaultIsEnabled: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Try to set the current state of Auto Boosted clocks on a device."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates"]
    #[doc = " to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock"]
    #[doc = " rates are desired."]
    #[doc = ""]
    #[doc = " Non-root users may use this API by default but can be restricted by root from using this API by calling"]
    #[doc = " \\ref nvmlDeviceSetAPIRestriction with apiType=NVML_RESTRICTED_API_SET_AUTO_BOOSTED_CLOCKS."]
    #[doc = " Note: Persistence Mode is required to modify current Auto Boost settings, therefore, it must be enabled."]
    #[doc = ""]
    #[doc = " On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks."]
    #[doc = " Use \\ref nvmlDeviceSetApplicationsClocks and \\ref nvmlDeviceResetApplicationsClocks to control Auto Boost"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param enabled                              What state to try to set Auto Boosted clocks of the target device to"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 If the Auto Boosted clocks were successfully set to the state specified by \\a enabled"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    pub fn nvmlDeviceSetAutoBoostedClocksEnabled(
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Try to set the default state of Auto Boosted clocks on a device. This is the default state that Auto Boosted clocks will"]
    #[doc = " return to when no compute running processes (e.g. CUDA application which have an active context) are running"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " Auto Boosted clocks are enabled by default on some hardware, allowing the GPU to run at higher clock rates"]
    #[doc = " to maximize performance as thermal limits allow. Auto Boosted clocks should be disabled if fixed clock"]
    #[doc = " rates are desired."]
    #[doc = ""]
    #[doc = " On Pascal and newer hardware, Auto Boosted clocks are controlled through application clocks."]
    #[doc = " Use \\ref nvmlDeviceSetApplicationsClocks and \\ref nvmlDeviceResetApplicationsClocks to control Auto Boost"]
    #[doc = " behavior."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param enabled                              What state to try to set default Auto Boosted clocks of the target device to"]
    #[doc = " @param flags                                Flags that change the default behavior. Currently Unused."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 If the Auto Boosted clock's default state was successfully set to the state specified by \\a enabled"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     If the calling user does not have permission to change Auto Boosted clock's default state."]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support Auto Boosted clocks"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    pub fn nvmlDeviceSetDefaultAutoBoostedClocksEnabled(
        device: nvmlDevice_t,
        enabled: nvmlEnableState_t,
        flags: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the intended operating speed of the device's fan."]
    #[doc = ""]
    #[doc = " Note: The reported speed is the intended fan speed.  If the fan is physically blocked and unable to spin, the"]
    #[doc = " output will not match the actual fan speed."]
    #[doc = ""]
    #[doc = " For all discrete products with dedicated fans."]
    #[doc = ""]
    #[doc = " The fan speed is expressed as a percent of the maximum, i.e. full speed is 100%."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param speed                                Reference in which to return the fan speed percentage"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a speed has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a speed is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a fan"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetFanSpeed(
        device: nvmlDevice_t,
        speed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the intended operating speed of the device's specified fan."]
    #[doc = ""]
    #[doc = " Note: The reported speed is the intended fan speed. If the fan is physically blocked and unable to spin, the"]
    #[doc = " output will not match the actual fan speed."]
    #[doc = ""]
    #[doc = " For all discrete products with dedicated fans."]
    #[doc = ""]
    #[doc = " The fan speed is expressed as a percentage of the maximum, i.e. full speed is 100%"]
    #[doc = ""]
    #[doc = " @param device                                The identifier of the target device"]
    #[doc = " @param fan                                   The index of the target fan, zero indexed."]
    #[doc = " @param speed                                 Reference in which to return the fan speed percentage"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "        - \\ref NVML_SUCCESS                   if \\a speed has been set"]
    #[doc = "        - \\ref NVML_ERROR_UNINITIALIZED       if the library has not been successfully initialized"]
    #[doc = "        - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a device is invalid, \\a fan is not an acceptable index, or \\a speed is NULL"]
    #[doc = "        - \\ref NVML_ERROR_NOT_SUPPORTED       if the device does not have a fan or is newer than Maxwell"]
    #[doc = "        - \\ref NVML_ERROR_GPU_IS_LOST         if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "        - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlDeviceGetFanSpeed_v2(
        device: nvmlDevice_t,
        fan: ::std::os::raw::c_uint,
        speed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current temperature readings for the device, in degrees C."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " See \\ref nvmlTemperatureSensors_t for details on available temperature sensors."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param sensorType                           Flag that indicates which sensor reading to retrieve"]
    #[doc = " @param temp                                 Reference in which to return the temperature reading"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a temp has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a sensorType is invalid or \\a temp is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have the specified sensor"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetTemperature(
        device: nvmlDevice_t,
        sensorType: nvmlTemperatureSensors_t,
        temp: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the temperature threshold for the GPU with the specified threshold type in degrees C."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlTemperatureThresholds_t for details on available temperature thresholds."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param thresholdType                        The type of threshold value queried"]
    #[doc = " @param temp                                 Reference in which to return the temperature reading"]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a temp has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a thresholdType is invalid or \\a temp is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not have a temperature sensor or is unsupported"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetTemperatureThreshold(
        device: nvmlDevice_t,
        thresholdType: nvmlTemperatureThresholds_t,
        temp: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current performance state for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlPstates_t for details on allowed performance states."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param pState                               Reference in which to return the performance state reading"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a pState has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pState is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPerformanceState(
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current clocks throttling reasons."]
    #[doc = ""]
    #[doc = " For all fully supported products."]
    #[doc = ""]
    #[doc = " \\note More than one bit can be enabled at the same time. Multiple reasons can be affecting clocks at once."]
    #[doc = ""]
    #[doc = " @param device                                The identifier of the target device"]
    #[doc = " @param clocksThrottleReasons                 Reference in which to return bitmask of active clocks throttle"]
    #[doc = "                                                  reasons"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a clocksThrottleReasons has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a clocksThrottleReasons is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlClocksThrottleReasons"]
    #[doc = " @see nvmlDeviceGetSupportedClocksThrottleReasons"]
    pub fn nvmlDeviceGetCurrentClocksThrottleReasons(
        device: nvmlDevice_t,
        clocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves bitmask of supported clocks throttle reasons that can be returned by"]
    #[doc = " \\ref nvmlDeviceGetCurrentClocksThrottleReasons"]
    #[doc = ""]
    #[doc = " For all fully supported products."]
    #[doc = ""]
    #[doc = " This method is not supported in virtual machines running virtual GPU (vGPU)."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param supportedClocksThrottleReasons       Reference in which to return bitmask of supported"]
    #[doc = "                                              clocks throttle reasons"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a supportedClocksThrottleReasons has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a supportedClocksThrottleReasons is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlClocksThrottleReasons"]
    #[doc = " @see nvmlDeviceGetCurrentClocksThrottleReasons"]
    pub fn nvmlDeviceGetSupportedClocksThrottleReasons(
        device: nvmlDevice_t,
        supportedClocksThrottleReasons: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Deprecated: Use \\ref nvmlDeviceGetPerformanceState. This function exposes an incorrect generalization."]
    #[doc = ""]
    #[doc = " Retrieve the current performance state for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlPstates_t for details on allowed performance states."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param pState                               Reference in which to return the performance state reading"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a pState has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a pState is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerState(
        device: nvmlDevice_t,
        pState: *mut nvmlPstates_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This API has been deprecated."]
    #[doc = ""]
    #[doc = " Retrieves the power management mode associated with this device."]
    #[doc = ""]
    #[doc = " For products from the Fermi family."]
    #[doc = "     - Requires \\a NVML_INFOROM_POWER version 3.0 or higher."]
    #[doc = ""]
    #[doc = " For from the Kepler or newer families."]
    #[doc = "     - Does not require \\a NVML_INFOROM_POWER object."]
    #[doc = ""]
    #[doc = " This flag indicates whether any power management algorithm is currently active on the device. An"]
    #[doc = " enabled state does not necessarily mean the device is being actively throttled -- only that"]
    #[doc = " that the driver will do so if the appropriate conditions are met."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for details on allowed modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 Reference in which to return the current power management mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a mode has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerManagementMode(
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the power management limit associated with this device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " The power limit defines the upper boundary for the card's power draw. If"]
    #[doc = " the card's total power draw reaches this limit the power management algorithm kicks in."]
    #[doc = ""]
    #[doc = " This reading is only available if power management mode is supported."]
    #[doc = " See \\ref nvmlDeviceGetPowerManagementMode."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param limit                                Reference in which to return the power management limit in milliwatts"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a limit has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a limit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerManagementLimit(
        device: nvmlDevice_t,
        limit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about possible values of power management limits on this device."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param minLimit                             Reference in which to return the minimum power management limit in milliwatts"]
    #[doc = " @param maxLimit                             Reference in which to return the maximum power management limit in milliwatts"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a minLimit and \\a maxLimit have been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minLimit or \\a maxLimit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetPowerManagementLimit"]
    pub fn nvmlDeviceGetPowerManagementLimitConstraints(
        device: nvmlDevice_t,
        minLimit: *mut ::std::os::raw::c_uint,
        maxLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves default power management limit on this device, in milliwatts."]
    #[doc = " Default power management limit is a power management limit that the device boots with."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param defaultLimit                         Reference in which to return the default power management limit in milliwatts"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a defaultLimit has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a defaultLimit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerManagementDefaultLimit(
        device: nvmlDevice_t,
        defaultLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves power usage for this GPU in milliwatts and its associated circuitry (e.g. memory)"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " On Fermi and Kepler GPUs the reading is accurate to within +/- 5% of current power draw."]
    #[doc = ""]
    #[doc = " It is only available if power management mode is supported. See \\ref nvmlDeviceGetPowerManagementMode."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param power                                Reference in which to return the power usage information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a power has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a power is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support power readings"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetPowerUsage(
        device: nvmlDevice_t,
        power: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves total energy consumption for this GPU in millijoules (mJ) since the driver was last reloaded"]
    #[doc = ""]
    #[doc = " For newer than Pascal &tm; fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param energy                               Reference in which to return the energy consumption information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a energy has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a energy is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support energy readings"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetTotalEnergyConsumption(
        device: nvmlDevice_t,
        energy: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the effective power limit that the driver enforces after taking into account all limiters"]
    #[doc = ""]
    #[doc = " Note: This can be different from the \\ref nvmlDeviceGetPowerManagementLimit if other limits are set elsewhere"]
    #[doc = " This includes the out of band power limit interface"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                           The device to communicate with"]
    #[doc = " @param limit                            Reference in which to return the power management limit in milliwatts"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a limit has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a limit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetEnforcedPowerLimit(
        device: nvmlDevice_t,
        limit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current GOM and pending GOM (the one that GPU will switch to after reboot)."]
    #[doc = ""]
    #[doc = " For GK110 M-class and X-class Tesla &tm; products from the Kepler family."]
    #[doc = " Modes \\ref NVML_GOM_LOW_DP and \\ref NVML_GOM_ALL_ON are supported on fully supported GeForce products."]
    #[doc = " Not supported on Quadro &reg; and Tesla &tm; C-class products."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param current                              Reference in which to return the current GOM"]
    #[doc = " @param pending                              Reference in which to return the pending GOM"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a mode has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a current or \\a pending is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlGpuOperationMode_t"]
    #[doc = " @see nvmlDeviceSetGpuOperationMode"]
    pub fn nvmlDeviceGetGpuOperationMode(
        device: nvmlDevice_t,
        current: *mut nvmlGpuOperationMode_t,
        pending: *mut nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the amount of used, free and total memory available on the device, in bytes."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " Enabling ECC reduces the amount of total available memory, due to the extra required parity bits."]
    #[doc = " Under WDDM most device memory is allocated and managed on startup by Windows."]
    #[doc = ""]
    #[doc = " Under Linux and Windows TCC, the reported amount of used memory is equal to the sum of memory allocated"]
    #[doc = " by all active channels on the device."]
    #[doc = ""]
    #[doc = " See \\ref nvmlMemory_t for details on available memory info."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param memory                               Reference in which to return the memory information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a memory has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a memory is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemoryInfo(device: nvmlDevice_t, memory: *mut nvmlMemory_t)
        -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current compute mode for the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " See \\ref nvmlComputeMode_t for details on allowed compute modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 Reference in which to return the current compute mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a mode has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetComputeMode()"]
    pub fn nvmlDeviceGetComputeMode(
        device: nvmlDevice_t,
        mode: *mut nvmlComputeMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the CUDA compute capability of the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " Returns the major and minor compute capability version numbers of the"]
    #[doc = " device.  The major and minor versions are equivalent to the"]
    #[doc = " CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MINOR and"]
    #[doc = " CU_DEVICE_ATTRIBUTE_COMPUTE_CAPABILITY_MAJOR attributes that would be"]
    #[doc = " returned by CUDA's cuDeviceGetAttribute()."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param major                                Reference in which to return the major CUDA compute capability"]
    #[doc = " @param minor                                Reference in which to return the minor CUDA compute capability"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a major and \\a minor have been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a major or \\a minor are NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetCudaComputeCapability(
        device: nvmlDevice_t,
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current and pending ECC modes for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " Only applicable to devices with ECC."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 1.0 or higher."]
    #[doc = ""]
    #[doc = " Changing ECC modes requires a reboot. The \"pending\" ECC mode refers to the target mode following"]
    #[doc = " the next reboot."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for details on allowed modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param current                              Reference in which to return the current ECC mode"]
    #[doc = " @param pending                              Reference in which to return the pending ECC mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a current and \\a pending have been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or either \\a current or \\a pending is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetEccMode()"]
    pub fn nvmlDeviceGetEccMode(
        device: nvmlDevice_t,
        current: *mut nvmlEnableState_t,
        pending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the device boardId from 0-N."]
    #[doc = " Devices with the same boardId indicate GPUs connected to the same PLX.  Use in conjunction with"]
    #[doc = "  \\ref nvmlDeviceGetMultiGpuBoard() to decide if they are on the same board as well."]
    #[doc = "  The boardId returned is a unique ID for the current configuration.  Uniqueness and ordering across"]
    #[doc = "  reboots and system configurations is not guaranteed (i.e. if a Tesla K40c returns 0x100 and"]
    #[doc = "  the two GPUs on a Tesla K10 in the same system returns 0x200 it is not guaranteed they will"]
    #[doc = "  always return those values but they will always be different from each other)."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param boardId                              Reference in which to return the device's board ID"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a boardId has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a boardId is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetBoardId(
        device: nvmlDevice_t,
        boardId: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves whether the device is on a Multi-GPU Board"]
    #[doc = " Devices that are on multi-GPU boards will set \\a multiGpuBool to a non-zero value."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param multiGpuBool                         Reference in which to return a zero or non-zero value"]
    #[doc = "                                                 to indicate whether the device is on a multi GPU board"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a multiGpuBool has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a multiGpuBool is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMultiGpuBoard(
        device: nvmlDevice_t,
        multiGpuBool: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the total ECC error counts for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " Only applicable to devices with ECC."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 1.0 or higher."]
    #[doc = " Requires ECC Mode to be enabled."]
    #[doc = ""]
    #[doc = " The total error count is the sum of errors across each of the separate memory systems, i.e. the total set of"]
    #[doc = " errors across the entire device."]
    #[doc = ""]
    #[doc = " See \\ref nvmlMemoryErrorType_t for a description of available error types.\\n"]
    #[doc = " See \\ref nvmlEccCounterType_t for a description of available counter types."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param errorType                            Flag that specifies the type of the errors."]
    #[doc = " @param counterType                          Flag that specifies the counter-type of the errors."]
    #[doc = " @param eccCounts                            Reference in which to return the specified ECC errors"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a eccCounts has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a errorType or \\a counterType is invalid, or \\a eccCounts is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceClearEccErrorCounts()"]
    pub fn nvmlDeviceGetTotalEccErrors(
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the detailed ECC error counts for the device."]
    #[doc = ""]
    #[doc = " @deprecated   This API supports only a fixed set of ECC error locations"]
    #[doc = "               On different GPU architectures different locations are supported"]
    #[doc = "               See \\ref nvmlDeviceGetMemoryErrorCounter"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " Only applicable to devices with ECC."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based ECC counts."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 1.0 or higher to report all other ECC counts."]
    #[doc = " Requires ECC Mode to be enabled."]
    #[doc = ""]
    #[doc = " Detailed errors provide separate ECC counts for specific parts of the memory system."]
    #[doc = ""]
    #[doc = " Reports zero for unsupported ECC error counters when a subset of ECC error counters are supported."]
    #[doc = ""]
    #[doc = " See \\ref nvmlMemoryErrorType_t for a description of available bit types.\\n"]
    #[doc = " See \\ref nvmlEccCounterType_t for a description of available counter types.\\n"]
    #[doc = " See \\ref nvmlEccErrorCounts_t for a description of provided detailed ECC counts."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param errorType                            Flag that specifies the type of the errors."]
    #[doc = " @param counterType                          Flag that specifies the counter-type of the errors."]
    #[doc = " @param eccCounts                            Reference in which to return the specified ECC errors"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a eccCounts has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a errorType or \\a counterType is invalid, or \\a eccCounts is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceClearEccErrorCounts()"]
    pub fn nvmlDeviceGetDetailedEccErrors(
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        eccCounts: *mut nvmlEccErrorCounts_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the requested memory error counter for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 2.0 or higher to report aggregate location-based memory error counts."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 1.0 or higher to report all other memory error counts."]
    #[doc = ""]
    #[doc = " Only applicable to devices with ECC."]
    #[doc = ""]
    #[doc = " Requires ECC Mode to be enabled."]
    #[doc = ""]
    #[doc = " See \\ref nvmlMemoryErrorType_t for a description of available memory error types.\\n"]
    #[doc = " See \\ref nvmlEccCounterType_t for a description of available counter types.\\n"]
    #[doc = " See \\ref nvmlMemoryLocation_t for a description of available counter locations.\\n"]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param errorType                            Flag that specifies the type of error."]
    #[doc = " @param counterType                          Flag that specifies the counter-type of the errors."]
    #[doc = " @param locationType                         Specifies the location of the counter."]
    #[doc = " @param count                                Reference in which to return the ECC counter"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a count has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a bitTyp,e \\a counterType or \\a locationType is"]
    #[doc = "                                             invalid, or \\a count is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support ECC error reporting in the specified memory"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetMemoryErrorCounter(
        device: nvmlDevice_t,
        errorType: nvmlMemoryErrorType_t,
        counterType: nvmlEccCounterType_t,
        locationType: nvmlMemoryLocation_t,
        count: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization rates for the device's major subsystems."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlUtilization_t for details on available utilization rates."]
    #[doc = ""]
    #[doc = " \\note During driver initialization when ECC is enabled one can see high GPU and Memory Utilization readings."]
    #[doc = "       This is caused by ECC Memory Scrubbing mechanism that is performed during driver initialization."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param utilization                          Reference in which to return the utilization information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a utilization has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a utilization is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetUtilizationRates(
        device: nvmlDevice_t,
        utilization: *mut nvmlUtilization_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization and sampling size in microseconds for the Encoder"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param utilization                          Reference to an unsigned int for encoder utilization info"]
    #[doc = " @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a utilization has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a utilization is NULL, or \\a samplingPeriodUs is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetEncoderUtilization(
        device: nvmlDevice_t,
        utilization: *mut ::std::os::raw::c_uint,
        samplingPeriodUs: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current capacity of the device's encoder, as a percentage of maximum encoder capacity with valid values in the range 0-100."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param encoderQueryType                  Type of encoder to query"]
    #[doc = " @param encoderCapacity                   Reference to an unsigned int for the encoder capacity"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a encoderCapacity is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a encoderCapacity is NULL, or \\a device or \\a encoderQueryType"]
    #[doc = "                                              are invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED      if device does not support the encoder specified in \\a encodeQueryType"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetEncoderCapacity(
        device: nvmlDevice_t,
        encoderQueryType: nvmlEncoderType_t,
        encoderCapacity: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current encoder statistics for a given device."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param sessionCount                      Reference to an unsigned int for count of active encoder sessions"]
    #[doc = " @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions"]
    #[doc = " @param averageLatency                    Reference to an unsigned int for encode latency in microseconds"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a sessionCount, \\a averageFps and \\a averageLatency is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount, or \\a device or \\a averageFps,"]
    #[doc = "                                              or \\a averageLatency is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetEncoderStats(
        device: nvmlDevice_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        averageFps: *mut ::std::os::raw::c_uint,
        averageLatency: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about active encoder sessions on a target device."]
    #[doc = ""]
    #[doc = " An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfos. The"]
    #[doc = " array elememt count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions"]
    #[doc = " written to the buffer."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the active session array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \\a sessionCount."]
    #[doc = " To query the number of active encoder sessions, call this function with *sessionCount = 0.  The code will return"]
    #[doc = " NVML_SUCCESS with number of active encoder sessions updated in *sessionCount."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions."]
    #[doc = " @param sessionInfos                      Reference in which to return the session information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a sessionInfos is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is returned in \\a sessionCount"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount is NULL."]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetEncoderSessions(
        device: nvmlDevice_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfos: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization and sampling size in microseconds for the Decoder"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param utilization                          Reference to an unsigned int for decoder utilization info"]
    #[doc = " @param samplingPeriodUs                     Reference to an unsigned int for the sampling period in US"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a utilization has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a utilization is NULL, or \\a samplingPeriodUs is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetDecoderUtilization(
        device: nvmlDevice_t,
        utilization: *mut ::std::os::raw::c_uint,
        samplingPeriodUs: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the active frame buffer capture sessions statistics for a given device."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a fbcStats is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a fbcStats is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetFBCStats(
        device: nvmlDevice_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about active frame buffer capture sessions on a target device."]
    #[doc = ""]
    #[doc = " An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfo. The"]
    #[doc = " array element count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions"]
    #[doc = " written to the buffer."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the active session array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \\a sessionCount."]
    #[doc = " To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return"]
    #[doc = " NVML_SUCCESS with number of active FBC sessions updated in *sessionCount."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \\a sessionInfo may"]
    #[doc = "       be zero if there are no new frames captured since the session started."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions."]
    #[doc = " @param sessionInfo                       Reference in which to return the session information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a sessionInfo is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is returned in \\a sessionCount"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount is NULL."]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetFBCSessions(
        device: nvmlDevice_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current and pending driver model for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " For windows only."]
    #[doc = ""]
    #[doc = " On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached"]
    #[doc = " to the device it must run in WDDM mode. TCC mode is preferred if a display is not attached."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDriverModel_t for details on available driver models."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param current                              Reference in which to return the current driver model"]
    #[doc = " @param pending                              Reference in which to return the pending driver model"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if either \\a current and/or \\a pending have been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or both \\a current and \\a pending are NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetDriverModel()"]
    pub fn nvmlDeviceGetDriverModel(
        device: nvmlDevice_t,
        current: *mut nvmlDriverModel_t,
        pending: *mut nvmlDriverModel_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get VBIOS version of the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " The VBIOS version may change from time to time. It will not exceed 32 characters in length"]
    #[doc = " (including the NULL terminator).  See \\ref nvmlConstants::NVML_DEVICE_VBIOS_VERSION_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param version                              Reference to which to return the VBIOS version"]
    #[doc = " @param length                               The maximum allowed length of the string returned in \\a version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a version is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetVbiosVersion(
        device: nvmlDevice_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get Bridge Chip Information for all the bridge chips on the board."]
    #[doc = ""]
    #[doc = " For all fully supported products."]
    #[doc = " Only applicable to multi-GPU products."]
    #[doc = ""]
    #[doc = " @param device                                The identifier of the target device"]
    #[doc = " @param bridgeHierarchy                       Reference to the returned bridge chip Hierarchy"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if bridge chip exists"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, or \\a bridgeInfo is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if bridge chip not supported on the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    pub fn nvmlDeviceGetBridgeChipInfo(
        device: nvmlDevice_t,
        bridgeHierarchy: *mut nvmlBridgeChipHierarchy_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get information about processes with a compute context on a device"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " This function returns information only about compute running processes (e.g. CUDA application which have"]
    #[doc = " active context). Any graphics applications (e.g. using OpenGL, DirectX) won't be listed by this function."]
    #[doc = ""]
    #[doc = " To query the current number of running compute processes, call this function with *infoCount = 0. The"]
    #[doc = " return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call"]
    #[doc = " \\a infos is allowed to be NULL."]
    #[doc = ""]
    #[doc = " The usedGpuMemory field returned is all of the memory used by the application."]
    #[doc = ""]
    #[doc = " Keep in mind that information returned by this call is dynamic and the number of elements might change in"]
    #[doc = " time. Allocate more space for \\a infos table in case new compute processes are spawned."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param infoCount                            Reference in which to provide the \\a infos array size, and"]
    #[doc = "                                             to return the number of returned elements"]
    #[doc = " @param infos                                Reference in which to return the process information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a infoCount and \\a infos have been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a infoCount indicates that the \\a infos array is too small"]
    #[doc = "                                             \\a infoCount will contain minimal amount of space necessary for"]
    #[doc = "                                             the call to complete"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, either of \\a infoCount or \\a infos is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see \\ref nvmlSystemGetProcessName"]
    pub fn nvmlDeviceGetComputeRunningProcesses(
        device: nvmlDevice_t,
        infoCount: *mut ::std::os::raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get information about processes with a graphics context on a device"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " This function returns information only about graphics based processes"]
    #[doc = " (eg. applications using OpenGL, DirectX)"]
    #[doc = ""]
    #[doc = " To query the current number of running graphics processes, call this function with *infoCount = 0. The"]
    #[doc = " return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if none are running. For this call"]
    #[doc = " \\a infos is allowed to be NULL."]
    #[doc = ""]
    #[doc = " The usedGpuMemory field returned is all of the memory used by the application."]
    #[doc = ""]
    #[doc = " Keep in mind that information returned by this call is dynamic and the number of elements might change in"]
    #[doc = " time. Allocate more space for \\a infos table in case new graphics processes are spawned."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param infoCount                            Reference in which to provide the \\a infos array size, and"]
    #[doc = "                                             to return the number of returned elements"]
    #[doc = " @param infos                                Reference in which to return the process information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a infoCount and \\a infos have been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a infoCount indicates that the \\a infos array is too small"]
    #[doc = "                                             \\a infoCount will contain minimal amount of space necessary for"]
    #[doc = "                                             the call to complete"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, either of \\a infoCount or \\a infos is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see \\ref nvmlSystemGetProcessName"]
    pub fn nvmlDeviceGetGraphicsRunningProcesses(
        device: nvmlDevice_t,
        infoCount: *mut ::std::os::raw::c_uint,
        infos: *mut nvmlProcessInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Check if the GPU devices are on the same physical board."]
    #[doc = ""]
    #[doc = " For all fully supported products."]
    #[doc = ""]
    #[doc = " @param device1                               The first GPU device"]
    #[doc = " @param device2                               The second GPU device"]
    #[doc = " @param onSameBoard                           Reference in which to return the status."]
    #[doc = "                                              Non-zero indicates that the GPUs are on the same board."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a onSameBoard has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a dev1 or \\a dev2 are invalid or \\a onSameBoard is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this check is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the either GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceOnSameBoard(
        device1: nvmlDevice_t,
        device2: nvmlDevice_t,
        onSameBoard: *mut ::std::os::raw::c_int,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the root/admin permissions on the target API. See \\a nvmlRestrictedAPI_t for the list of supported APIs."]
    #[doc = " If an API is restricted only root users can call that API. See \\a nvmlDeviceSetAPIRestriction to change current permissions."]
    #[doc = ""]
    #[doc = " For all fully supported products."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param apiType                              Target API type for this operation"]
    #[doc = " @param isRestricted                         Reference in which to return the current restriction"]
    #[doc = "                                             NVML_FEATURE_ENABLED indicates that the API is root-only"]
    #[doc = "                                             NVML_FEATURE_DISABLED indicates that the API is accessible to all users"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a isRestricted has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a apiType incorrect or \\a isRestricted is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device or the device does not support"]
    #[doc = "                                                 the feature that is being queried (E.G. Enabling/disabling Auto Boosted clocks is"]
    #[doc = "                                                 not supported by the device)"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlRestrictedAPI_t"]
    pub fn nvmlDeviceGetAPIRestriction(
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets recent samples for the GPU."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Based on type, this method can be used to fetch the power, utilization or clock samples maintained in the buffer by"]
    #[doc = " the driver."]
    #[doc = ""]
    #[doc = " Power, Utilization and Clock samples are returned as type \"unsigned int\" for the union nvmlValue_t."]
    #[doc = ""]
    #[doc = " To get the size of samples that user needs to allocate, the method is invoked with samples set to NULL."]
    #[doc = " The returned samplesCount will provide the number of samples that can be queried. The user needs to"]
    #[doc = " allocate the buffer with size as samplesCount * sizeof(nvmlSample_t)."]
    #[doc = ""]
    #[doc = " lastSeenTimeStamp represents CPU timestamp in microseconds. Set it to 0 to fetch all the samples maintained by the"]
    #[doc = " underlying buffer. Set lastSeenTimeStamp to one of the timeStamps retrieved from the date of the previous query"]
    #[doc = " to get more recent samples."]
    #[doc = ""]
    #[doc = " This method fetches the number of entries which can be accommodated in the provided samples array, and the"]
    #[doc = " reference samplesCount is updated to indicate how many samples were actually retrieved. The advantage of using this"]
    #[doc = " method for samples in contrast to polling via existing methods is to get get higher frequency data at lower polling cost."]
    #[doc = ""]
    #[doc = " @param device                        The identifier for the target device"]
    #[doc = " @param type                          Type of sampling event"]
    #[doc = " @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp."]
    #[doc = " @param sampleValType                 Output parameter to represent the type of sample value as described in nvmlSampleVal_t"]
    #[doc = " @param sampleCount                   Reference to provide the number of elements which can be queried in samples array"]
    #[doc = " @param samples                       Reference in which samples are returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if samples are successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a samplesCount is NULL or"]
    #[doc = "                                             reference to \\a sampleCount is 0 for non null \\a samples"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetSamples(
        device: nvmlDevice_t,
        type_: nvmlSamplingType_t,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        sampleCount: *mut ::std::os::raw::c_uint,
        samples: *mut nvmlSample_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets Total, Available and Used size of BAR1 memory."]
    #[doc = ""]
    #[doc = " BAR1 is used to map the FB (device memory) so that it can be directly accessed by the CPU or by 3rd party"]
    #[doc = " devices (peer-to-peer on the PCIE bus)."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param bar1Memory                           Reference in which BAR1 memory"]
    #[doc = "                                             information is returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if BAR1 memory is successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a bar1Memory is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    pub fn nvmlDeviceGetBAR1MemoryInfo(
        device: nvmlDevice_t,
        bar1Memory: *mut nvmlBAR1Memory_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Gets the duration of time during which the device was throttled (lower than requested clocks) due to power"]
    #[doc = " or thermal constraints."]
    #[doc = ""]
    #[doc = " The method is important to users who are tying to understand if their GPUs throttle at any point during their applications. The"]
    #[doc = " difference in violation times at two different reference times gives the indication of GPU throttling event."]
    #[doc = ""]
    #[doc = " Violation for thermal capping is not supported at this time."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param perfPolicyType                       Represents Performance policy which can trigger GPU throttling"]
    #[doc = " @param violTime                             Reference to which violation time related information is returned"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if violation time is successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a perfPolicyType is invalid, or \\a violTime is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this query is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = ""]
    pub fn nvmlDeviceGetViolationStatus(
        device: nvmlDevice_t,
        perfPolicyType: nvmlPerfPolicyType_t,
        violTime: *mut nvmlViolationTime_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries the state of per process accounting mode."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDeviceGetAccountingStats for more details."]
    #[doc = " See \\ref nvmlDeviceSetAccountingMode"]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 Reference in which to return the current accounting mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the mode has been successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode are NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetAccountingMode(
        device: nvmlDevice_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries process's accounting stats."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Accounting stats capture GPU utilization and other statistics across the lifetime of a process."]
    #[doc = " Accounting stats can be queried during life time of the process and after its termination."]
    #[doc = " The time field in \\ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and"]
    #[doc = " updated to actual running time after its termination."]
    #[doc = " Accounting stats are kept in a circular buffer, newly created processes overwrite information about old"]
    #[doc = " processes."]
    #[doc = ""]
    #[doc = " See \\ref nvmlAccountingStats_t for description of each returned metric."]
    #[doc = " List of processes that can be queried can be retrieved from \\ref nvmlDeviceGetAccountingPids."]
    #[doc = ""]
    #[doc = " @note Accounting Mode needs to be on. See \\ref nvmlDeviceGetAccountingMode."]
    #[doc = " @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be"]
    #[doc = "         queried since they don't contribute to GPU utilization."]
    #[doc = " @note In case of pid collision stats of only the latest process (that terminated last) will be reported"]
    #[doc = ""]
    #[doc = " @warning On Kepler devices per process statistics are accurate only if there's one process running on a GPU."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param pid                                  Process Id of the target process to query stats for"]
    #[doc = " @param stats                                Reference in which to return the process's accounting stats"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if stats have been successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a stats are NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if process stats were not found"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetAccountingBufferSize"]
    pub fn nvmlDeviceGetAccountingStats(
        device: nvmlDevice_t,
        pid: ::std::os::raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries list of processes that can be queried for accounting stats. The list of processes returned"]
    #[doc = " can be in running or terminated state."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " To just query the number of processes ready to be queried, call this function with *count = 0 and"]
    #[doc = " pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty."]
    #[doc = ""]
    #[doc = " For more details see \\ref nvmlDeviceGetAccountingStats."]
    #[doc = ""]
    #[doc = " @note In case of PID collision some processes might not be accessible before the circular buffer is full."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param count                                Reference in which to provide the \\a pids array size, and"]
    #[doc = "                                               to return the number of elements ready to be queried"]
    #[doc = " @param pids                                 Reference in which to return list of process ids"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if pids were successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a count is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small (\\a count is set to"]
    #[doc = "                                                 expected value)"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetAccountingBufferSize"]
    pub fn nvmlDeviceGetAccountingPids(
        device: nvmlDevice_t,
        count: *mut ::std::os::raw::c_uint,
        pids: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the number of processes that the circular buffer with accounting pids can hold."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " This is the maximum number of processes that accounting information will be stored for before information"]
    #[doc = " about oldest processes will get overwritten by information about new processes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param bufferSize                           Reference in which to provide the size (in number of elements)"]
    #[doc = "                                               of the circular buffer for accounting stats."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if buffer size was successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a bufferSize is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature or accounting mode is disabled"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetAccountingStats"]
    #[doc = " @see nvmlDeviceGetAccountingPids"]
    pub fn nvmlDeviceGetAccountingBufferSize(
        device: nvmlDevice_t,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the list of retired pages by source, including pages that are pending retirement"]
    #[doc = " The address information provided from this API is the hardware address of the page that was retired.  Note"]
    #[doc = " that this does not match the virtual address used in CUDA, but will match the address information in XID 63"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param cause                             Filter page addresses by cause of retirement"]
    #[doc = " @param pageCount                         Reference in which to provide the \\a addresses buffer size, and"]
    #[doc = "                                          to return the number of retired pages that match \\a cause"]
    #[doc = "                                          Set to 0 to query the size without allocating an \\a addresses buffer"]
    #[doc = " @param addresses                         Buffer to write the page addresses into"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a pageCount was populated and \\a addresses was filled"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a pageCount indicates the buffer is not large enough to store all the"]
    #[doc = "                                             matching page addresses.  \\a pageCount is set to the needed size."]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a pageCount is NULL, \\a cause is invalid, or"]
    #[doc = "                                             \\a addresses is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetRetiredPages(
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut ::std::os::raw::c_uint,
        addresses: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the list of retired pages by source, including pages that are pending retirement"]
    #[doc = " The address information provided from this API is the hardware address of the page that was retired.  Note"]
    #[doc = " that this does not match the virtual address used in CUDA, but will match the address information in XID 63"]
    #[doc = ""]
    #[doc = " \\note nvmlDeviceGetRetiredPages_v2 adds an additional timestamps paramter to return the time of each page's"]
    #[doc = "       retirement."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param cause                             Filter page addresses by cause of retirement"]
    #[doc = " @param pageCount                         Reference in which to provide the \\a addresses buffer size, and"]
    #[doc = "                                          to return the number of retired pages that match \\a cause"]
    #[doc = "                                          Set to 0 to query the size without allocating an \\a addresses buffer"]
    #[doc = " @param addresses                         Buffer to write the page addresses into"]
    #[doc = " @param timestamps                        Buffer to write the timestamps of page retirement, additional for _v2"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a pageCount was populated and \\a addresses was filled"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a pageCount indicates the buffer is not large enough to store all the"]
    #[doc = "                                             matching page addresses.  \\a pageCount is set to the needed size."]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a pageCount is NULL, \\a cause is invalid, or"]
    #[doc = "                                             \\a addresses is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetRetiredPages_v2(
        device: nvmlDevice_t,
        cause: nvmlPageRetirementCause_t,
        pageCount: *mut ::std::os::raw::c_uint,
        addresses: *mut ::std::os::raw::c_ulonglong,
        timestamps: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Check if any pages are pending retirement and need a reboot to fully retire."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                            The identifier of the target device"]
    #[doc = " @param isPending                         Reference in which to return the pending status"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a isPending was populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a isPending is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetRetiredPagesPendingStatus(
        device: nvmlDevice_t,
        isPending: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the LED state for the unit. The LED can be either green (0) or amber (1)."]
    #[doc = ""]
    #[doc = " For S-class products."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " This operation takes effect immediately."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " <b>Current S-Class products don't provide unique LEDs for each unit. As such, both front"]
    #[doc = " and back LEDs will be toggled in unison regardless of which unit is specified with this command.</b>"]
    #[doc = ""]
    #[doc = " See \\ref nvmlLedColor_t for available colors."]
    #[doc = ""]
    #[doc = " @param unit                                 The identifier of the target unit"]
    #[doc = " @param color                                The target LED color"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the LED color has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a unit or \\a color is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if this is not an S-class product"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlUnitGetLedState()"]
    pub fn nvmlUnitSetLedState(unit: nvmlUnit_t, color: nvmlLedColor_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the persistence mode for the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = " For Linux only."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " The persistence mode determines whether the GPU driver software is torn down after the last client"]
    #[doc = " exits."]
    #[doc = ""]
    #[doc = " This operation takes effect immediately. It is not persistent across reboots. After each reboot the"]
    #[doc = " persistence mode is reset to \"Disabled\"."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for available modes."]
    #[doc = ""]
    #[doc = " After calling this API with mode set to NVML_FEATURE_DISABLED on a device that has its own NUMA"]
    #[doc = " memory, the given device handle will no longer be valid, and to continue to interact with this"]
    #[doc = " device, a new handle should be obtained from one of the nvmlDeviceGetHandleBy*() APIs. This"]
    #[doc = " limitation is currently only applicable to devices that have a coherent NVLink connection to"]
    #[doc = " system memory."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 The target persistence mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the persistence mode was set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetPersistenceMode()"]
    pub fn nvmlDeviceSetPersistenceMode(
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the compute mode for the device."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " The compute mode determines whether a GPU can be used for compute operations and whether it can"]
    #[doc = " be shared across contexts."]
    #[doc = ""]
    #[doc = " This operation takes effect immediately. Under Linux it is not persistent across reboots and"]
    #[doc = " always resets to \"Default\". Under windows it is persistent."]
    #[doc = ""]
    #[doc = " Under windows compute mode may only be set to DEFAULT when running in WDDM"]
    #[doc = ""]
    #[doc = " See \\ref nvmlComputeMode_t for details on available compute modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 The target compute mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the compute mode was set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetComputeMode()"]
    pub fn nvmlDeviceSetComputeMode(device: nvmlDevice_t, mode: nvmlComputeMode_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the ECC mode for the device."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Only applicable to devices with ECC."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 1.0 or higher."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " The ECC mode determines whether the GPU enables its ECC support."]
    #[doc = ""]
    #[doc = " This operation takes effect after the next reboot."]
    #[doc = ""]
    #[doc = " See \\ref nvmlEnableState_t for details on available modes."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param ecc                                  The target ECC mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the ECC mode was set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a ecc is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetEccMode()"]
    pub fn nvmlDeviceSetEccMode(device: nvmlDevice_t, ecc: nvmlEnableState_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clear the ECC error and other memory error counts for the device."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Only applicable to devices with ECC."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 2.0 or higher to clear aggregate location-based ECC counts."]
    #[doc = " Requires \\a NVML_INFOROM_ECC version 1.0 or higher to clear all other ECC counts."]
    #[doc = " Requires root/admin permissions."]
    #[doc = " Requires ECC Mode to be enabled."]
    #[doc = ""]
    #[doc = " Sets all of the specified ECC counters to 0, including both detailed and total counts."]
    #[doc = ""]
    #[doc = " This operation takes effect immediately."]
    #[doc = ""]
    #[doc = " See \\ref nvmlMemoryErrorType_t for details on available counter types."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param counterType                          Flag that indicates which type of errors should be cleared."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the error counts were cleared"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a counterType is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see"]
    #[doc = "      - nvmlDeviceGetDetailedEccErrors()"]
    #[doc = "      - nvmlDeviceGetTotalEccErrors()"]
    pub fn nvmlDeviceClearEccErrorCounts(
        device: nvmlDevice_t,
        counterType: nvmlEccCounterType_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the driver model for the device."]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " For windows only."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " On Windows platforms the device driver can run in either WDDM or WDM (TCC) mode. If a display is attached"]
    #[doc = " to the device it must run in WDDM mode."]
    #[doc = ""]
    #[doc = " It is possible to force the change to WDM (TCC) while the display is still attached with a force flag (nvmlFlagForce)."]
    #[doc = " This should only be done if the host is subsequently powered down and the display is detached from the device"]
    #[doc = " before the next reboot."]
    #[doc = ""]
    #[doc = " This operation takes effect after the next reboot."]
    #[doc = ""]
    #[doc = " Windows driver model may only be set to WDDM when running in DEFAULT compute mode."]
    #[doc = ""]
    #[doc = " Change driver model to WDDM is not supported when GPU doesn't support graphics acceleration or"]
    #[doc = " will not support it after reboot. See \\ref nvmlDeviceSetGpuOperationMode."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDriverModel_t for details on available driver models."]
    #[doc = " See \\ref nvmlFlagDefault and \\ref nvmlFlagForce"]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param driverModel                          The target driver model"]
    #[doc = " @param flags                                Flags that change the default behavior"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the driver model has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a driverModel is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the platform is not windows or the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetDriverModel()"]
    pub fn nvmlDeviceSetDriverModel(
        device: nvmlDevice_t,
        driverModel: nvmlDriverModel_t,
        flags: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set clocks that device will lock to."]
    #[doc = ""]
    #[doc = " Sets the clocks that the device will be running at to the value in the range of minGpuClockMHz to maxGpuClockMHz."]
    #[doc = " Setting this will supercede application clock values and take effect regardless if a cuda app is running."]
    #[doc = " See /ref nvmlDeviceSetApplicationsClocks"]
    #[doc = ""]
    #[doc = " Can be used as a setting to request constant performance."]
    #[doc = ""]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " After system reboot or driver reload applications clocks go back to their default value."]
    #[doc = " See \\ref nvmlDeviceResetGpuLockedClocks."]
    #[doc = ""]
    #[doc = " For newer than Pascal &tm; fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param minGpuClockMHz                       Requested minimum gpu clock in MHz"]
    #[doc = " @param maxGpuClockMHz                       Requested maximum gpu clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if new settings were successfully set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a minGpuClockMHz and \\a maxGpuClockMHz"]
    #[doc = "                                                 is not a valid clock combination"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetGpuLockedClocks(
        device: nvmlDevice_t,
        minGpuClockMHz: ::std::os::raw::c_uint,
        maxGpuClockMHz: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets the gpu clock to the default value"]
    #[doc = ""]
    #[doc = " This is the gpu clock that will be used after system reboot or driver reload."]
    #[doc = " Default values are idle clocks, but the current values can be changed using \\ref nvmlDeviceSetApplicationsClocks."]
    #[doc = ""]
    #[doc = " @see nvmlDeviceSetGpuLockedClocks"]
    #[doc = ""]
    #[doc = " For newer than Pascal &tm; fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if new settings were successfully set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetGpuLockedClocks(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set clocks that applications will lock to."]
    #[doc = ""]
    #[doc = " Sets the clocks that compute and graphics applications will be running at."]
    #[doc = " e.g. CUDA driver requests these clocks during context creation which means this property"]
    #[doc = " defines clocks at which CUDA applications will be running unless some overspec event"]
    #[doc = " occurs (e.g. over power, over thermal or external HW brake)."]
    #[doc = ""]
    #[doc = " Can be used as a setting to request constant performance."]
    #[doc = ""]
    #[doc = " On Pascal and newer hardware, this will automatically disable automatic boosting of clocks."]
    #[doc = ""]
    #[doc = " On K80 and newer Kepler and Maxwell GPUs, users desiring fixed performance should also call"]
    #[doc = " \\ref nvmlDeviceSetAutoBoostedClocksEnabled to prevent clocks from automatically boosting"]
    #[doc = " above the clock value being set."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer non-GeForce fully supported devices and Maxwell or newer GeForce devices."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDeviceGetSupportedMemoryClocks and \\ref nvmlDeviceGetSupportedGraphicsClocks"]
    #[doc = " for details on how to list available clocks combinations."]
    #[doc = ""]
    #[doc = " After system reboot or driver reload applications clocks go back to their default value."]
    #[doc = " See \\ref nvmlDeviceResetApplicationsClocks."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param memClockMHz                          Requested memory clock in MHz"]
    #[doc = " @param graphicsClockMHz                     Requested graphics clock in MHz"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if new settings were successfully set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a memClockMHz and \\a graphicsClockMHz"]
    #[doc = "                                                 is not a valid clock combination"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetApplicationsClocks(
        device: nvmlDevice_t,
        memClockMHz: ::std::os::raw::c_uint,
        graphicsClockMHz: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set new power limit of this device."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDeviceGetPowerManagementLimitConstraints to check the allowed ranges of values."]
    #[doc = ""]
    #[doc = " \\note Limit is not persistent across reboots or driver unloads."]
    #[doc = " Enable persistent mode to prevent driver from unloading when no application is using the device."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param limit                                Power management limit in milliwatts to set"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a limit has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a defaultLimit is out of range"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceGetPowerManagementLimitConstraints"]
    #[doc = " @see nvmlDeviceGetPowerManagementDefaultLimit"]
    pub fn nvmlDeviceSetPowerManagementLimit(
        device: nvmlDevice_t,
        limit: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Sets new GOM. See \\a nvmlGpuOperationMode_t for details."]
    #[doc = ""]
    #[doc = " For GK110 M-class and X-class Tesla &tm; products from the Kepler family."]
    #[doc = " Modes \\ref NVML_GOM_LOW_DP and \\ref NVML_GOM_ALL_ON are supported on fully supported GeForce products."]
    #[doc = " Not supported on Quadro &reg; and Tesla &tm; C-class products."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " Changing GOMs requires a reboot."]
    #[doc = " The reboot requirement might be removed in the future."]
    #[doc = ""]
    #[doc = " Compute only GOMs don't support graphics acceleration. Under windows switching to these GOMs when"]
    #[doc = " pending driver model is WDDM is not supported. See \\ref nvmlDeviceSetDriverModel."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 Target GOM"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a mode has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a mode incorrect"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support GOM or specific mode"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlGpuOperationMode_t"]
    #[doc = " @see nvmlDeviceGetGpuOperationMode"]
    pub fn nvmlDeviceSetGpuOperationMode(
        device: nvmlDevice_t,
        mode: nvmlGpuOperationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Changes the root/admin restructions on certain APIs. See \\a nvmlRestrictedAPI_t for the list of supported APIs."]
    #[doc = " This method can be used by a root/admin user to give non-root/admin access to certain otherwise-restricted APIs."]
    #[doc = " The new setting lasts for the lifetime of the NVIDIA driver; it is not persistent. See \\a nvmlDeviceGetAPIRestriction"]
    #[doc = " to query the current restriction settings."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param apiType                              Target API type for this operation"]
    #[doc = " @param isRestricted                         The target restriction"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a isRestricted has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a apiType incorrect"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support changing API restrictions or the device does not support"]
    #[doc = "                                                 the feature that api restrictions are being set for (E.G. Enabling/disabling auto"]
    #[doc = "                                                 boosted clocks is not supported by the device)"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlRestrictedAPI_t"]
    pub fn nvmlDeviceSetAPIRestriction(
        device: nvmlDevice_t,
        apiType: nvmlRestrictedAPI_t,
        isRestricted: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Enables or disables per process accounting."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " @note This setting is not persistent and will default to disabled after driver unloads."]
    #[doc = "       Enable persistence mode to be sure the setting doesn't switch off to disabled."]
    #[doc = ""]
    #[doc = " @note Enabling accounting mode has no negative impact on the GPU performance."]
    #[doc = ""]
    #[doc = " @note Disabling accounting clears all accounting pids information."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDeviceGetAccountingMode"]
    #[doc = " See \\ref nvmlDeviceGetAccountingStats"]
    #[doc = " See \\ref nvmlDeviceClearAccountingPids"]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param mode                                 The target accounting mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the new mode has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a mode are invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetAccountingMode(
        device: nvmlDevice_t,
        mode: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Clears accounting information about all processes that have already terminated."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = " Requires root/admin permissions."]
    #[doc = ""]
    #[doc = " See \\ref nvmlDeviceGetAccountingMode"]
    #[doc = " See \\ref nvmlDeviceGetAccountingStats"]
    #[doc = " See \\ref nvmlDeviceSetAccountingMode"]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if accounting information has been cleared"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device are invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the user doesn't have permission to perform this operation"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceClearAccountingPids(device: nvmlDevice_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the state of the device's NvLink for the link specified"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param isActive                             \\a nvmlEnableState_t where NVML_FEATURE_ENABLED indicates that"]
    #[doc = "                                             the link is active and NVML_FEATURE_DISABLED indicates it"]
    #[doc = "                                             is inactive"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a isActive has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid or \\a isActive is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkState(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        isActive: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the version of the device's NvLink for the link specified"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param version                              Requested NvLink version"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid or \\a version is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkVersion(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        version: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the requested capability from the device's NvLink for the link specified"]
    #[doc = " Please refer to the \\a nvmlNvLinkCapability_t structure for the specific caps that can be queried"]
    #[doc = " The return value should be treated as a boolean."]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param capability                           Specifies the \\a nvmlNvLinkCapability_t to be queried"]
    #[doc = " @param capResult                            A boolean for the queried capability indicating that feature is available"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a capResult has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, or \\a capability is invalid or \\a capResult is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkCapability(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        capability: nvmlNvLinkCapability_t,
        capResult: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetNvLinkRemotePciInfo_v2(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        pci: *mut nvmlPciInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the specified error counter value"]
    #[doc = " Please refer to \\a nvmlNvLinkErrorCounter_t for error counters that are available"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param counter                              Specifies the NvLink counter to be queried"]
    #[doc = " @param counterValue                         Returned counter value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a counter has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, or \\a counter is invalid or \\a counterValue is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkErrorCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: nvmlNvLinkErrorCounter_t,
        counterValue: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Resets all error counters to zero"]
    #[doc = " Please refer to \\a nvmlNvLinkErrorCounter_t for the list of error counters that are reset"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the reset is successful"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device or \\a link is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetNvLinkErrorCounters(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the NVLINK utilization counter control information for the specified counter, 0 or 1."]
    #[doc = " Please refer to \\a nvmlNvLinkUtilizationControl_t for the structure definition.  Performs a reset"]
    #[doc = " of the counters if the reset parameter is non-zero."]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param counter                              Specifies the counter that should be set (0 or 1)."]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param control                              A reference to the \\a nvmlNvLinkUtilizationControl_t to set"]
    #[doc = " @param reset                                Resets the counters on set if non-zero"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the control has been set successfully"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a counter, \\a link, or \\a control is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceSetNvLinkUtilizationControl(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
        reset: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Get the NVLINK utilization counter control information for the specified counter, 0 or 1."]
    #[doc = " Please refer to \\a nvmlNvLinkUtilizationControl_t for the structure definition"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param counter                              Specifies the counter that should be set (0 or 1)."]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param control                              A reference to the \\a nvmlNvLinkUtilizationControl_t to place information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the control has been set successfully"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a counter, \\a link, or \\a control is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkUtilizationControl(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        control: *mut nvmlNvLinkUtilizationControl_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the NVLINK utilization counter based on the current control for a specified counter."]
    #[doc = " In general it is good practice to use \\a nvmlDeviceSetNvLinkUtilizationControl"]
    #[doc = "  before reading the utilization counters as they have no default state"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param counter                              Specifies the counter that should be read (0 or 1)."]
    #[doc = " @param rxcounter                            Receive counter return value"]
    #[doc = " @param txcounter                            Transmit counter return value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a rxcounter and \\a txcounter have been successfully set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a counter, or \\a link is invalid or \\a rxcounter or \\a txcounter are NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetNvLinkUtilizationCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        rxcounter: *mut ::std::os::raw::c_ulonglong,
        txcounter: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Freeze the NVLINK utilization counters"]
    #[doc = " Both the receive and transmit counters are operated on by this function"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be queried"]
    #[doc = " @param counter                              Specifies the counter that should be frozen (0 or 1)."]
    #[doc = " @param freeze                               NVML_FEATURE_ENABLED = freeze the receive and transmit counters"]
    #[doc = "                                             NVML_FEATURE_DISABLED = unfreeze the receive and transmit counters"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if counters were successfully frozen or unfrozen"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, \\a counter, or \\a freeze is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceFreezeNvLinkUtilizationCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
        freeze: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Reset the NVLINK utilization counters"]
    #[doc = " Both the receive and transmit counters are operated on by this function"]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param link                                 Specifies the NvLink link to be reset"]
    #[doc = " @param counter                              Specifies the counter that should be reset (0 or 1)"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if counters were successfully reset"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device, \\a link, or \\a counter is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceResetNvLinkUtilizationCounter(
        device: nvmlDevice_t,
        link: ::std::os::raw::c_uint,
        counter: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Create an empty set of events."]
    #[doc = " Event set should be freed by \\ref nvmlEventSetFree"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " @param set                                  Reference in which to return the event handle"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the event has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a set is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlEventSetFree"]
    pub fn nvmlEventSetCreate(set: *mut nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Starts recording of events on a specified devices and add the events to specified \\ref nvmlEventSet_t"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = " Ecc events are available only on ECC enabled devices (see \\ref nvmlDeviceGetTotalEccErrors)"]
    #[doc = " Power capping events are available only on Power Management enabled devices (see \\ref nvmlDeviceGetPowerManagementMode)"]
    #[doc = ""]
    #[doc = " For Linux only."]
    #[doc = ""]
    #[doc = " \\b IMPORTANT: Operations on \\a set are not thread safe"]
    #[doc = ""]
    #[doc = " This call starts recording of events on specific device."]
    #[doc = " All events that occurred before this call are not recorded."]
    #[doc = " Checking if some event occurred can be done with \\ref nvmlEventSetWait"]
    #[doc = ""]
    #[doc = " If function reports NVML_ERROR_UNKNOWN, event set is in undefined state and should be freed."]
    #[doc = " If function reports NVML_ERROR_NOT_SUPPORTED, event set can still be used. None of the requested eventTypes"]
    #[doc = "     are registered in that case."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param eventTypes                           Bitmask of \\ref nvmlEventType to record"]
    #[doc = " @param set                                  Set to which add new event types"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the event has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a eventTypes is invalid or \\a set is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the platform does not support this feature or some of requested event types"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlEventType"]
    #[doc = " @see nvmlDeviceGetSupportedEventTypes"]
    #[doc = " @see nvmlEventSetWait"]
    #[doc = " @see nvmlEventSetFree"]
    pub fn nvmlDeviceRegisterEvents(
        device: nvmlDevice_t,
        eventTypes: ::std::os::raw::c_ulonglong,
        set: nvmlEventSet_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns information about events supported on device"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Events are not supported on Windows. So this function returns an empty mask in \\a eventTypes on Windows."]
    #[doc = ""]
    #[doc = " @param device                               The identifier of the target device"]
    #[doc = " @param eventTypes                           Reference in which to return bitmask of supported events"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the eventTypes has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a eventType is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlEventType"]
    #[doc = " @see nvmlDeviceRegisterEvents"]
    pub fn nvmlDeviceGetSupportedEventTypes(
        device: nvmlDevice_t,
        eventTypes: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Waits on events and delivers events"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " If some events are ready to be delivered at the time of the call, function returns immediately."]
    #[doc = " If there are no events ready to be delivered, function sleeps till event arrives"]
    #[doc = " but not longer than specified timeout. This function in certain conditions can return before"]
    #[doc = " specified timeout passes (e.g. when interrupt arrives)"]
    #[doc = ""]
    #[doc = " In case of xid error, the function returns the most recent xid error type seen by the system. If there are multiple"]
    #[doc = " xid errors generated before nvmlEventSetWait is invoked then the last seen xid error type is returned for all"]
    #[doc = " xid error events."]
    #[doc = ""]
    #[doc = " @param set                                  Reference to set of events to wait on"]
    #[doc = " @param data                                 Reference in which to return event data"]
    #[doc = " @param timeoutms                            Maximum amount of wait time in milliseconds for registered event"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the data has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a data is NULL"]
    #[doc = "         - \\ref NVML_ERROR_TIMEOUT           if no event arrived in specified timeout or interrupt arrived"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if a GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlEventType"]
    #[doc = " @see nvmlDeviceRegisterEvents"]
    pub fn nvmlEventSetWait(
        set: nvmlEventSet_t,
        data: *mut nvmlEventData_t,
        timeoutms: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Releases events in the set"]
    #[doc = ""]
    #[doc = " For Fermi &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param set                                  Reference to events to be released"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the event has been successfully released"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlDeviceRegisterEvents"]
    pub fn nvmlEventSetFree(set: nvmlEventSet_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Modify the drain state of a GPU.  This method forces a GPU to no longer accept new incoming requests."]
    #[doc = " Any new NVML process will no longer see this GPU.  Persistence mode for this GPU must be turned off before"]
    #[doc = " this call is made."]
    #[doc = " Must be called as administrator."]
    #[doc = " For Linux only."]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = " Some Kepler devices supported."]
    #[doc = ""]
    #[doc = " @param pciInfo                              The PCI address of the GPU drain state to be modified"]
    #[doc = " @param newState                             The drain state that should be entered, see \\ref nvmlEnableState_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if counters were successfully reset"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a nvmlIndex or \\a newState is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation"]
    #[doc = "         - \\ref NVML_ERROR_IN_USE            if the device has persistence mode turned on"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceModifyDrainState(
        pciInfo: *mut nvmlPciInfo_t,
        newState: nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Query the drain state of a GPU.  This method is used to check if a GPU is in a currently draining"]
    #[doc = " state."]
    #[doc = " For Linux only."]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = " Some Kepler devices supported."]
    #[doc = ""]
    #[doc = " @param pciInfo                              The PCI address of the GPU drain state to be queried"]
    #[doc = " @param currentState                         The current drain state for this GPU, see \\ref nvmlEnableState_t"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if counters were successfully reset"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a nvmlIndex or \\a currentState is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceQueryDrainState(
        pciInfo: *mut nvmlPciInfo_t,
        currentState: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceRemoveGpu_v2(
        pciInfo: *mut nvmlPciInfo_t,
        gpuState: nvmlDetachGpuState_t,
        linkState: nvmlPcieLinkState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Request the OS and the NVIDIA kernel driver to rediscover a portion of the PCI subsystem looking for GPUs that"]
    #[doc = " were previously removed. The portion of the PCI tree can be narrowed by specifying a domain, bus, and device."]
    #[doc = " If all are zeroes then the entire PCI tree will be searched.  Please note that for long-running NVML processes"]
    #[doc = " the enumeration will change based on how many GPUs are discovered and where they are inserted in bus order."]
    #[doc = ""]
    #[doc = " In addition, all newly discovered GPUs will be initialized and their ECC scrubbed which may take several seconds"]
    #[doc = " per GPU. Also, all device handles are no longer guaranteed to be valid post discovery."]
    #[doc = ""]
    #[doc = " Must be run as administrator."]
    #[doc = " For Linux only."]
    #[doc = ""]
    #[doc = " For Pascal &tm; or newer fully supported devices."]
    #[doc = " Some Kepler devices supported."]
    #[doc = ""]
    #[doc = " @param pciInfo                              The PCI tree to be searched.  Only the domain, bus, and device"]
    #[doc = "                                             fields are used in this call."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if counters were successfully reset"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a pciInfo is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the operating system does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_OPERATING_SYSTEM  if the operating system is denying this feature"]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION     if the calling process has insufficient permissions to perform operation"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceDiscoverGpus(pciInfo: *mut nvmlPciInfo_t) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Request values for a list of fields for a device. This API allows multiple fields to be queried at once."]
    #[doc = " If any of the underlying fieldIds are populated by the same driver call, the results for those field IDs"]
    #[doc = " will be populated from a single call rather than making a driver call for each fieldId."]
    #[doc = ""]
    #[doc = " @param device                               The device handle of the GPU to request field values for"]
    #[doc = " @param valuesCount                          Number of entries in values that should be retrieved"]
    #[doc = " @param values                               Array of \\a valuesCount structures to hold field values."]
    #[doc = "                                             Each value's fieldId must be populated prior to this call"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if any values in \\a values were populated. Note that you must"]
    #[doc = "                                             check the nvmlReturn field of each value for each individual"]
    #[doc = "                                             status"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid or \\a values is NULL"]
    pub fn nvmlDeviceGetFieldValues(
        device: nvmlDevice_t,
        valuesCount: ::std::os::raw::c_int,
        values: *mut nvmlFieldValue_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This method is used to get the virtualization mode corresponding to the GPU."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                    Identifier of the target device"]
    #[doc = " @param pVirtualMode              Reference to virtualization mode. One of NVML_GPU_VIRTUALIZATION_?"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a pVirtualMode is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid or \\a pVirtualMode is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetVirtualizationMode(
        device: nvmlDevice_t,
        pVirtualMode: *mut nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " This method is used to set the virtualization mode corresponding to the GPU."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                    Identifier of the target device"]
    #[doc = " @param virtualMode               virtualization mode. One of NVML_GPU_VIRTUALIZATION_?"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a pVirtualMode is set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid or \\a pVirtualMode is NULL"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST        if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED      if setting of virtualization mode is not supported."]
    #[doc = "         - \\ref NVML_ERROR_NO_PERMISSION      if setting of virtualization mode is not allowed for this client."]
    pub fn nvmlDeviceSetVirtualizationMode(
        device: nvmlDevice_t,
        virtualMode: nvmlGpuVirtualizationMode_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the supported vGPU types on a physical GPU (device)."]
    #[doc = ""]
    #[doc = " An array of supported vGPU types for the physical GPU indicated by \\a device is returned in the caller-supplied buffer"]
    #[doc = " pointed at by \\a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \\a vgpuCount, and \\a vgpuCount"]
    #[doc = " is used to return the number of vGPU types written to the buffer."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \\a vgpuCount."]
    #[doc = " To query the number of vGPU types supported for the GPU, call this function with *vgpuCount = 0."]
    #[doc = " The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are supported."]
    #[doc = ""]
    #[doc = " @param device                   The identifier of the target device"]
    #[doc = " @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types"]
    #[doc = " @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                      successful completion"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE      \\a vgpuTypeIds buffer is too small, array element count is returned in \\a vgpuCount"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT       if \\a vgpuCount is NULL or \\a device is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN                on any unexpected error"]
    pub fn nvmlDeviceGetSupportedVgpus(
        device: nvmlDevice_t,
        vgpuCount: *mut ::std::os::raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the currently creatable vGPU types on a physical GPU (device)."]
    #[doc = ""]
    #[doc = " An array of creatable vGPU types for the physical GPU indicated by \\a device is returned in the caller-supplied buffer"]
    #[doc = " pointed at by \\a vgpuTypeIds. The element count of nvmlVgpuTypeId_t array is passed in \\a vgpuCount, and \\a vgpuCount"]
    #[doc = " is used to return the number of vGPU types written to the buffer."]
    #[doc = ""]
    #[doc = " The creatable vGPU types for a device may differ over time, as there may be restrictions on what type of vGPU types"]
    #[doc = " can concurrently run on a device.  For example, if only one vGPU type is allowed at a time on a device, then the creatable"]
    #[doc = " list will be restricted to whatever vGPU type is already running on the device."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the vGPU type array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuTypeId_t array required in \\a vgpuCount."]
    #[doc = " To query the number of vGPU types createable for the GPU, call this function with *vgpuCount = 0."]
    #[doc = " The code will return NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU types are creatable."]
    #[doc = ""]
    #[doc = " @param device                   The identifier of the target device"]
    #[doc = " @param vgpuCount                Pointer to caller-supplied array size, and returns number of vGPU types"]
    #[doc = " @param vgpuTypeIds              Pointer to caller-supplied array in which to return list of vGPU types"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                      successful completion"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE      \\a vgpuTypeIds buffer is too small, array element count is returned in \\a vgpuCount"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT       if \\a vgpuCount is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED          if vGPU is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_VGPU_ECC_NOT_SUPPORTED if ECC is enabled on the device"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN                on any unexpected error"]
    pub fn nvmlDeviceGetCreatableVgpus(
        device: nvmlDevice_t,
        vgpuCount: *mut ::std::os::raw::c_uint,
        vgpuTypeIds: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the class of a vGPU type. It will not exceed 64 characters in length (including the NUL terminator)."]
    #[doc = " See \\ref nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param vgpuTypeClass            Pointer to string array to return class in"]
    #[doc = " @param size                     Size of string"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   successful completion"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a vgpuTypeId is invalid, or \\a vgpuTypeClass is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   if \\a size is too small"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlVgpuTypeGetClass(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeClass: *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU type name."]
    #[doc = ""]
    #[doc = " The name is an alphanumeric string that denotes a particular vGPU, e.g. GRID M60-2Q. It will not"]
    #[doc = " exceed 64 characters in length (including the NUL terminator).  See \\ref"]
    #[doc = " nvmlConstants::NVML_DEVICE_NAME_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param vgpuTypeName             Pointer to buffer to return name"]
    #[doc = " @param size                     Size of buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a name is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetName(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeName: *mut ::std::os::raw::c_char,
        size: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the device ID of a vGPU type."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param deviceID                 Device ID and vendor ID of the device contained in single 32 bit value"]
    #[doc = " @param subsystemID              Subsytem ID and subsytem vendor ID of the device contained in single 32 bit value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a deviceId or \\a subsystemID are NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetDeviceID(
        vgpuTypeId: nvmlVgpuTypeId_t,
        deviceID: *mut ::std::os::raw::c_ulonglong,
        subsystemID: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU framebuffer size in bytes."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param fbSize                   Pointer to framebuffer size in bytes"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a fbSize is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetFramebufferSize(
        vgpuTypeId: nvmlVgpuTypeId_t,
        fbSize: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve count of vGPU's supported display heads."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param numDisplayHeads          Pointer to number of display heads"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a numDisplayHeads is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetNumDisplayHeads(
        vgpuTypeId: nvmlVgpuTypeId_t,
        numDisplayHeads: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve vGPU display head's maximum supported resolution."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param displayIndex             Zero-based index of display head"]
    #[doc = " @param xdim                     Pointer to maximum number of pixels in X dimension"]
    #[doc = " @param ydim                     Pointer to maximum number of pixels in Y dimension"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a xdim or \\a ydim are NULL, or \\a displayIndex"]
    #[doc = "                                             is out of range."]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetResolution(
        vgpuTypeId: nvmlVgpuTypeId_t,
        displayIndex: ::std::os::raw::c_uint,
        xdim: *mut ::std::os::raw::c_uint,
        ydim: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve license requirements for a vGPU type"]
    #[doc = ""]
    #[doc = " The license type and version required to run the specified vGPU type is returned as an alphanumeric string, in the form"]
    #[doc = " \"<license name>,<version>\", for example \"GRID-Virtual-PC,2.0\". If a vGPU is runnable with* more than one type of license,"]
    #[doc = " the licenses are delimited by a semicolon, for example \"GRID-Virtual-PC,2.0;GRID-Virtual-WS,2.0;GRID-Virtual-WS-Ext,2.0\"."]
    #[doc = ""]
    #[doc = " The total length of the returned string will not exceed 128 characters, including the NUL terminator."]
    #[doc = " See \\ref nvmlVgpuConstants::NVML_GRID_LICENSE_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param vgpuTypeLicenseString    Pointer to buffer to return license info"]
    #[doc = " @param size                     Size of \\a vgpuTypeLicenseString buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a vgpuTypeLicenseString is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetLicense(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuTypeLicenseString: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the static frame rate limit value of the vGPU type"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param frameRateLimit           Reference to return the frame rate limit value"]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a frameRateLimit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetFrameRateLimit(
        vgpuTypeId: nvmlVgpuTypeId_t,
        frameRateLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the maximum number of vGPU instances creatable on a device for given vGPU type"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                   The identifier of the target device"]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param vgpuInstanceCount        Pointer to get the max number of vGPU instances"]
    #[doc = "                                 that can be created on a deicve for given vgpuTypeId"]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid or is not supported on target device,"]
    #[doc = "                                             or \\a vgpuInstanceCount is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetMaxInstances(
        device: nvmlDevice_t,
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCount: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the maximum number of vGPU instances supported per VM for given vGPU type"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuTypeId               Handle to vGPU type"]
    #[doc = " @param vgpuInstanceCountPerVm   Pointer to get the max number of vGPU instances supported per VM for given \\a vgpuTypeId"]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuTypeId is invalid, or \\a vgpuInstanceCountPerVm is NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuTypeGetMaxInstancesPerVm(
        vgpuTypeId: nvmlVgpuTypeId_t,
        vgpuInstanceCountPerVm: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the active vGPU instances on a device."]
    #[doc = ""]
    #[doc = " An array of active vGPU instances is returned in the caller-supplied buffer pointed at by \\a vgpuInstances. The"]
    #[doc = " array elememt count is passed in \\a vgpuCount, and \\a vgpuCount is used to return the number of vGPU instances"]
    #[doc = " written to the buffer."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the vGPU instance array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlVgpuInstance_t array required in \\a vgpuCount."]
    #[doc = " To query the number of active vGPU instances, call this function with *vgpuCount = 0.  The code will return"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if no vGPU Types are supported."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param device                   The identifier of the target device"]
    #[doc = " @param vgpuCount                Pointer which passes in the array size as well as get"]
    #[doc = "                                 back the number of types"]
    #[doc = " @param vgpuInstances            Pointer to array in which to return list of vGPU instances"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a device is invalid, or \\a vgpuCount is NULL"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a size is too small"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED      if vGPU is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlDeviceGetActiveVgpus(
        device: nvmlDevice_t,
        vgpuCount: *mut ::std::os::raw::c_uint,
        vgpuInstances: *mut nvmlVgpuInstance_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the VM ID associated with a vGPU instance."]
    #[doc = ""]
    #[doc = " The VM ID is returned as a string, not exceeding 80 characters in length (including the NUL terminator)."]
    #[doc = " See \\ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " The format of the VM ID varies by platform, and is indicated by the type identifier returned in \\a vmIdType."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param vmId                     Pointer to caller-supplied buffer to hold VM ID"]
    #[doc = " @param size                     Size of buffer in bytes"]
    #[doc = " @param vmIdType                 Pointer to hold VM ID type"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vmId or \\a vmIdType is NULL, or \\a vgpuInstance is 0"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetVmID(
        vgpuInstance: nvmlVgpuInstance_t,
        vmId: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        vmIdType: *mut nvmlVgpuVmIdType_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the UUID of a vGPU instance."]
    #[doc = ""]
    #[doc = " The UUID is a globally unique identifier associated with the vGPU, and is returned as a 5-part hexadecimal string,"]
    #[doc = " not exceeding 80 characters in length (including the NULL terminator)."]
    #[doc = " See \\ref nvmlConstants::NVML_DEVICE_UUID_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param uuid                     Pointer to caller-supplied buffer to hold vGPU UUID"]
    #[doc = " @param size                     Size of buffer in bytes"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a uuid is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a size is too small"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetUUID(
        vgpuInstance: nvmlVgpuInstance_t,
        uuid: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the NVIDIA driver version installed in the VM associated with a vGPU."]
    #[doc = ""]
    #[doc = " The version is returned as an alphanumeric string in the caller-supplied buffer \\a version. The length of the version"]
    #[doc = " string will not exceed 80 characters in length (including the NUL terminator)."]
    #[doc = " See \\ref nvmlConstants::NVML_SYSTEM_DRIVER_VERSION_BUFFER_SIZE."]
    #[doc = ""]
    #[doc = " nvmlVgpuInstanceGetVmDriverVersion() may be called at any time for a vGPU instance. The guest VM driver version is"]
    #[doc = " returned as \"Unknown\" if no NVIDIA driver is installed in the VM, or the VM has not yet booted to the point where the"]
    #[doc = " NVIDIA driver is loaded and initialized."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param version                  Caller-supplied buffer to return driver version string"]
    #[doc = " @param length                   Size of \\a version buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a version has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a length is too small"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetVmDriverVersion(
        vgpuInstance: nvmlVgpuInstance_t,
        version: *mut ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the framebuffer usage in bytes."]
    #[doc = ""]
    #[doc = " Framebuffer usage is the amont of vGPU framebuffer memory that is currently in use by the VM."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             The identifier of the target instance"]
    #[doc = " @param fbUsage                  Pointer to framebuffer usage in bytes"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 successful completion"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a fbUsage is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFbUsage(
        vgpuInstance: nvmlVgpuInstance_t,
        fbUsage: *mut ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the current licensing state of the vGPU instance."]
    #[doc = ""]
    #[doc = " If the vGPU is currently licensed, \\a licensed is set to 1, otherwise it is set to 0."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param licensed                 Reference to return the licensing status"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a licensed has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a licensed is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetLicenseStatus(
        vgpuInstance: nvmlVgpuInstance_t,
        licensed: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the vGPU type of a vGPU instance."]
    #[doc = ""]
    #[doc = " Returns the vGPU type ID of vgpu assigned to the vGPU instance."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param vgpuTypeId               Reference to return the vgpuTypeId"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a vgpuTypeId has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a vgpuTypeId is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetType(
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuTypeId: *mut nvmlVgpuTypeId_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the frame rate limit set for the vGPU instance."]
    #[doc = ""]
    #[doc = " Returns the value of the frame rate limit set for the vGPU instance"]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param frameRateLimit           Reference to return the frame rate limit"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a frameRateLimit has been set"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if frame rate limiter is turned off for the vGPU type"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a frameRateLimit is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFrameRateLimit(
        vgpuInstance: nvmlVgpuInstance_t,
        frameRateLimit: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieve the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param encoderCapacity          Reference to an unsigned int for the encoder capacity"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a encoderCapacity has been retrived"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a encoderQueryType is invalid"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEncoderCapacity(
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Set the encoder capacity of a vGPU instance, as a percentage of maximum encoder capacity with valid values in the range 0-100."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             Identifier of the target vGPU instance"]
    #[doc = " @param encoderCapacity          Unsigned int for the encoder capacity value"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a encoderCapacity has been set"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a encoderCapacity is out of range of 0-100."]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceSetEncoderCapacity(
        vgpuInstance: nvmlVgpuInstance_t,
        encoderCapacity: ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current utilization for vGPUs on a physical GPU (device)."]
    #[doc = ""]
    #[doc = " For Kepler &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for vGPU instances running"]
    #[doc = " on a device. Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer"]
    #[doc = " pointed at by \\a utilizationSamples. One utilization sample structure is returned per vGPU instance, and includes the"]
    #[doc = " CPU timestamp at which the samples were recorded. Individual utilization values are returned as \"unsigned int\" values"]
    #[doc = " in nvmlValue_t unions. The function sets the caller-supplied \\a sampleValType to NVML_VALUE_TYPE_UNSIGNED_INT to"]
    #[doc = " indicate the returned value type."]
    #[doc = ""]
    #[doc = " To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with"]
    #[doc = " \\a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance"]
    #[doc = " count in \\a vgpuInstanceSamplesCount, or NVML_SUCCESS if the current vGPU instance count is zero. The caller should allocate"]
    #[doc = " a buffer of size vgpuInstanceSamplesCount * sizeof(nvmlVgpuInstanceUtilizationSample_t). Invoke the function again with"]
    #[doc = " the allocated buffer passed in \\a utilizationSamples, and \\a vgpuInstanceSamplesCount set to the number of entries the"]
    #[doc = " buffer is sized for."]
    #[doc = ""]
    #[doc = " On successful return, the function updates \\a vgpuInstanceSampleCount with the number of vGPU utilization sample"]
    #[doc = " structures that were actually written. This may differ from a previously read value as vGPU instances are created or"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0"]
    #[doc = " to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp"]
    #[doc = " to a timeStamp retrieved from a previous query to read utilization since the previous query."]
    #[doc = ""]
    #[doc = " @param device                        The identifier for the target device"]
    #[doc = " @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp."]
    #[doc = " @param sampleValType                 Pointer to caller-supplied buffer to hold the type of returned sample values"]
    #[doc = " @param vgpuInstanceSamplesCount      Pointer to caller-supplied array size, and returns number of vGPU instances"]
    #[doc = " @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU utilization samples are returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if utilization samples are successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a vgpuInstanceSamplesCount or \\a sampleValType is"]
    #[doc = "                                             NULL, or a sample count of 0 is passed with a non-NULL \\a utilizationSamples"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \\a vgpuInstanceSamplesCount is too small to return samples for all"]
    #[doc = "                                             vGPU instances currently executing on the device"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetVgpuUtilization(
        device: nvmlDevice_t,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
        sampleValType: *mut nvmlValueType_t,
        vgpuInstanceSamplesCount: *mut ::std::os::raw::c_uint,
        utilizationSamples: *mut nvmlVgpuInstanceUtilizationSample_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves current utilization for processes running on vGPUs on a physical GPU (device)."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running on"]
    #[doc = " vGPU instances active on a device. Utilization values are returned as an array of utilization sample structures in the"]
    #[doc = " caller-supplied buffer pointed at by \\a utilizationSamples. One utilization sample structure is returned per process running"]
    #[doc = " on vGPU instances, that had some non-zero utilization during the last sample period. It includes the CPU timestamp at which"]
    #[doc = " the samples were recorded. Individual utilization values are returned as \"unsigned int\" values."]
    #[doc = ""]
    #[doc = " To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with"]
    #[doc = " \\a utilizationSamples set to NULL. The function will return NVML_ERROR_INSUFFICIENT_SIZE, with the current vGPU instance"]
    #[doc = " count in \\a vgpuProcessSamplesCount. The caller should allocate a buffer of size"]
    #[doc = " vgpuProcessSamplesCount * sizeof(nvmlVgpuProcessUtilizationSample_t). Invoke the function again with"]
    #[doc = " the allocated buffer passed in \\a utilizationSamples, and \\a vgpuProcessSamplesCount set to the number of entries the"]
    #[doc = " buffer is sized for."]
    #[doc = ""]
    #[doc = " On successful return, the function updates \\a vgpuSubProcessSampleCount with the number of vGPU sub process utilization sample"]
    #[doc = " structures that were actually written. This may differ from a previously read value depending on the number of processes that are active"]
    #[doc = " in any given sample period."]
    #[doc = ""]
    #[doc = " lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0"]
    #[doc = " to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp"]
    #[doc = " to a timeStamp retrieved from a previous query to read utilization since the previous query."]
    #[doc = ""]
    #[doc = " @param device                        The identifier for the target device"]
    #[doc = " @param lastSeenTimeStamp             Return only samples with timestamp greater than lastSeenTimeStamp."]
    #[doc = " @param vgpuProcessSamplesCount       Pointer to caller-supplied array size, and returns number of processes running on vGPU instances"]
    #[doc = " @param utilizationSamples            Pointer to caller-supplied buffer in which vGPU sub process utilization samples are returned"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if utilization samples are successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a vgpuProcessSamplesCount or a sample count of 0 is"]
    #[doc = "                                             passed with a non-NULL \\a utilizationSamples"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if supplied \\a vgpuProcessSamplesCount is too small to return samples for all"]
    #[doc = "                                             vGPU instances currently executing on the device"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if vGPU is not supported by the device"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if sample entries are not found"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetVgpuProcessUtilization(
        device: nvmlDevice_t,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
        vgpuProcessSamplesCount: *mut ::std::os::raw::c_uint,
        utilizationSamples: *mut nvmlVgpuProcessUtilizationSample_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    pub fn nvmlDeviceGetGridLicensableFeatures_v2(
        device: nvmlDevice_t,
        pGridLicensableFeatures: *mut nvmlGridLicensableFeatures_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current encoder statistics of a vGPU Instance"]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance                      Identifier of the target vGPU instance"]
    #[doc = " @param sessionCount                      Reference to an unsigned int for count of active encoder sessions"]
    #[doc = " @param averageFps                        Reference to an unsigned int for trailing average FPS of all active sessions"]
    #[doc = " @param averageLatency                    Reference to an unsigned int for encode latency in microseconds"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a sessionCount, \\a averageFps and \\a averageLatency is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount , or \\a averageFps or \\a averageLatency is NULL"]
    #[doc = "                                              or \\a vgpuInstance is 0."]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEncoderStats(
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        averageFps: *mut ::std::os::raw::c_uint,
        averageLatency: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about all active encoder sessions on a vGPU Instance."]
    #[doc = ""]
    #[doc = " An array of active encoder sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfo. The"]
    #[doc = " array element count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions"]
    #[doc = " written to the buffer."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the active session array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlEncoderSessionInfo_t array required in \\a sessionCount."]
    #[doc = " To query the number of active encoder sessions, call this function with *sessionCount = 0. The code will return"]
    #[doc = " NVML_SUCCESS with number of active encoder sessions updated in *sessionCount."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance                      Identifier of the target vGPU instance"]
    #[doc = " @param sessionCount                      Reference to caller supplied array size, and returns"]
    #[doc = "                                          the number of sessions."]
    #[doc = " @param sessionInfo                       Reference to caller supplied array in which the list"]
    #[doc = "                                          of session information us returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a sessionInfo is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is"]
    #[doc = "returned in \\a sessionCount"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a sessionCount is NULL, or \\a vgpuInstance is 0."]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetEncoderSessions(
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfo: *mut nvmlEncoderSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the active frame buffer capture sessions statistics of a vGPU Instance"]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance                      Identifier of the target vGPU instance"]
    #[doc = " @param fbcStats                          Reference to nvmlFBCStats_t structure contianing NvFBC stats"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a fbcStats is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a vgpuInstance is 0, or \\a fbcStats is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFBCStats(
        vgpuInstance: nvmlVgpuInstance_t,
        fbcStats: *mut nvmlFBCStats_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves information about active frame buffer capture sessions on a vGPU Instance."]
    #[doc = ""]
    #[doc = " An array of active FBC sessions is returned in the caller-supplied buffer pointed at by \\a sessionInfo. The"]
    #[doc = " array element count is passed in \\a sessionCount, and \\a sessionCount is used to return the number of sessions"]
    #[doc = " written to the buffer."]
    #[doc = ""]
    #[doc = " If the supplied buffer is not large enough to accomodate the active session array, the function returns"]
    #[doc = " NVML_ERROR_INSUFFICIENT_SIZE, with the element count of nvmlFBCSessionInfo_t array required in \\a sessionCount."]
    #[doc = " To query the number of active FBC sessions, call this function with *sessionCount = 0.  The code will return"]
    #[doc = " NVML_SUCCESS with number of active FBC sessions updated in *sessionCount."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @note hResolution, vResolution, averageFPS and averageLatency data for a FBC session returned in \\a sessionInfo may"]
    #[doc = "       be zero if there are no new frames captured since the session started."]
    #[doc = ""]
    #[doc = " @param vgpuInstance                      Identifier of the target vGPU instance"]
    #[doc = " @param sessionCount                      Reference to caller supplied array size, and returns the number of sessions."]
    #[doc = " @param sessionInfo                       Reference in which to return the session information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a sessionInfo is fetched"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED      if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a vgpuInstance is 0, or \\a sessionCount is NULL."]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND          if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE  if \\a sessionCount is too small, array element count is returned in \\a sessionCount"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN            on any unexpected error"]
    pub fn nvmlVgpuInstanceGetFBCSessions(
        vgpuInstance: nvmlVgpuInstance_t,
        sessionCount: *mut ::std::os::raw::c_uint,
        sessionInfo: *mut nvmlFBCSessionInfo_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Retrieves the current utilization and process ID"]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Reads recent utilization of GPU SM (3D/Compute), framebuffer, video encoder, and video decoder for processes running."]
    #[doc = " Utilization values are returned as an array of utilization sample structures in the caller-supplied buffer pointed at"]
    #[doc = " by \\a utilization. One utilization sample structure is returned per process running, that had some non-zero utilization"]
    #[doc = " during the last sample period. It includes the CPU timestamp at which  the samples were recorded. Individual utilization values"]
    #[doc = " are returned as \"unsigned int\" values."]
    #[doc = ""]
    #[doc = " To read utilization values, first determine the size of buffer required to hold the samples by invoking the function with"]
    #[doc = " \\a utilization set to NULL. The caller should allocate a buffer of size"]
    #[doc = " processSamplesCount * sizeof(nvmlProcessUtilizationSample_t). Invoke the function again with the allocated buffer passed"]
    #[doc = " in \\a utilization, and \\a processSamplesCount set to the number of entries the buffer is sized for."]
    #[doc = ""]
    #[doc = " On successful return, the function updates \\a processSamplesCount with the number of process utilization sample"]
    #[doc = " structures that were actually written. This may differ from a previously read value as instances are created or"]
    #[doc = " destroyed."]
    #[doc = ""]
    #[doc = " lastSeenTimeStamp represents the CPU timestamp in microseconds at which utilization samples were last read. Set it to 0"]
    #[doc = " to read utilization based on all the samples maintained by the driver's internal sample buffer. Set lastSeenTimeStamp"]
    #[doc = " to a timeStamp retrieved from a previous query to read utilization since the previous query."]
    #[doc = ""]
    #[doc = " @param device                    The identifier of the target device"]
    #[doc = " @param utilization               Pointer to caller-supplied buffer in which guest process utilization samples are returned"]
    #[doc = " @param processSamplesCount       Pointer to caller-supplied array size, and returns number of processes running"]
    #[doc = " @param lastSeenTimeStamp         Return only samples with timestamp greater than lastSeenTimeStamp."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a utilization has been populated"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a device is invalid, \\a utilization is NULL, or \\a samplingPeriodUs is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the device does not support this feature"]
    #[doc = "         - \\ref NVML_ERROR_GPU_IS_LOST       if the target GPU has fallen off the bus or is otherwise inaccessible"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlDeviceGetProcessUtilization(
        device: nvmlDevice_t,
        utilization: *mut nvmlProcessUtilizationSample_t,
        processSamplesCount: *mut ::std::os::raw::c_uint,
        lastSeenTimeStamp: ::std::os::raw::c_ulonglong,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries the state of per process accounting mode on vGPU."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " @param vgpuInstance            The identifier of the target vGPU VM"]
    #[doc = " @param mode                    Reference in which to return the current accounting mode"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if the mode has been successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a mode is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetAccountingMode(
        vgpuInstance: nvmlVgpuInstance_t,
        mode: *mut nvmlEnableState_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries list of processes running on vGPU that can be queried for accounting stats. The list of processes"]
    #[doc = " returned can be in running or terminated state."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " To just query the maximum number of processes that can be queried, call this function with *count = 0 and"]
    #[doc = " pids=NULL. The return code will be NVML_ERROR_INSUFFICIENT_SIZE, or NVML_SUCCESS if list is empty."]
    #[doc = ""]
    #[doc = " For more details see \\ref nvmlVgpuInstanceGetAccountingStats."]
    #[doc = ""]
    #[doc = " @note In case of PID collision some processes might not be accessible before the circular buffer is full."]
    #[doc = ""]
    #[doc = " @param vgpuInstance            The identifier of the target vGPU VM"]
    #[doc = " @param count                   Reference in which to provide the \\a pids array size, and"]
    #[doc = "                                to return the number of elements ready to be queried"]
    #[doc = " @param pids                    Reference in which to return list of process ids"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if pids were successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a count is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE if \\a count is too small (\\a count is set to expected value)"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    #[doc = ""]
    #[doc = " @see nvmlVgpuInstanceGetAccountingPids"]
    pub fn nvmlVgpuInstanceGetAccountingPids(
        vgpuInstance: nvmlVgpuInstance_t,
        count: *mut ::std::os::raw::c_uint,
        pids: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Queries process's accounting stats."]
    #[doc = ""]
    #[doc = " For Maxwell &tm; or newer fully supported devices."]
    #[doc = ""]
    #[doc = " Accounting stats capture GPU utilization and other statistics across the lifetime of a process, and"]
    #[doc = " can be queried during life time of the process or after its termination."]
    #[doc = " The time field in \\ref nvmlAccountingStats_t is reported as 0 during the lifetime of the process and"]
    #[doc = " updated to actual running time after its termination."]
    #[doc = " Accounting stats are kept in a circular buffer, newly created processes overwrite information about old"]
    #[doc = " processes."]
    #[doc = ""]
    #[doc = " See \\ref nvmlAccountingStats_t for description of each returned metric."]
    #[doc = " List of processes that can be queried can be retrieved from \\ref nvmlVgpuInstanceGetAccountingPids."]
    #[doc = ""]
    #[doc = " @note Accounting Mode needs to be on. See \\ref nvmlVgpuInstanceGetAccountingMode."]
    #[doc = " @note Only compute and graphics applications stats can be queried. Monitoring applications stats can't be"]
    #[doc = "         queried since they don't contribute to GPU utilization."]
    #[doc = " @note In case of pid collision stats of only the latest process (that terminated last) will be reported"]
    #[doc = ""]
    #[doc = " @param vgpuInstance            The identifier of the target vGPU VM"]
    #[doc = " @param pid                     Process Id of the target process to query stats for"]
    #[doc = " @param stats                   Reference in which to return the process's accounting stats"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if stats have been successfully retrieved"]
    #[doc = "         - \\ref NVML_ERROR_UNINITIALIZED     if the library has not been successfully initialized"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a vgpuInstance is 0, or \\a stats is NULL"]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND         if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "                                             or \\a stats is not found"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED     if the vGPU doesn't support this feature or accounting mode is disabled"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN           on any unexpected error"]
    pub fn nvmlVgpuInstanceGetAccountingStats(
        vgpuInstance: nvmlVgpuInstance_t,
        pid: ::std::os::raw::c_uint,
        stats: *mut nvmlAccountingStats_t,
    ) -> nvmlReturn_t;
}
#[doc = " Structure representing a range of vGPU version"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuVersion_st {
    #[doc = "!< Minimum vGPU version."]
    pub minVersion: ::std::os::raw::c_uint,
    #[doc = "!< Maximum vGPU version."]
    pub maxVersion: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_nvmlVgpuVersion_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuVersion_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlVgpuVersion_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuVersion_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuVersion_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuVersion_st>())).minVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuVersion_st),
            "::",
            stringify!(minVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuVersion_st>())).maxVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuVersion_st),
            "::",
            stringify!(maxVersion)
        )
    );
}
pub type nvmlVgpuVersion_t = nvmlVgpuVersion_st;
#[doc = " vGPU metadata structure."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuMetadata_st {
    #[doc = "!< Current version of the structure"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Current revision of the structure"]
    pub revision: ::std::os::raw::c_uint,
    #[doc = "!< Current state of Guest-dependent fields"]
    pub guestInfoState: nvmlVgpuGuestInfoState_t,
    #[doc = "!< Version of driver installed in guest"]
    pub guestDriverVersion: [::std::os::raw::c_char; 80usize],
    #[doc = "!< Version of driver installed in host"]
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    #[doc = "!< Reserved for internal use"]
    pub reserved: [::std::os::raw::c_uint; 7usize],
    #[doc = "!< vGPU version of guest driver"]
    pub guestVgpuVersion: ::std::os::raw::c_uint,
    #[doc = "!< Size of opaque data field in bytes"]
    pub opaqueDataSize: ::std::os::raw::c_uint,
    #[doc = "!< Opaque data"]
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_nvmlVgpuMetadata_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuMetadata_st>(),
        212usize,
        concat!("Size of: ", stringify!(nvmlVgpuMetadata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuMetadata_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuMetadata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).revision as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).guestInfoState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(guestInfoState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).guestDriverVersion as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(guestDriverVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).hostDriverVersion as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(hostDriverVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).reserved as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).guestVgpuVersion as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(guestVgpuVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).opaqueDataSize as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(opaqueDataSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuMetadata_st>())).opaqueData as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuMetadata_st),
            "::",
            stringify!(opaqueData)
        )
    );
}
pub type nvmlVgpuMetadata_t = nvmlVgpuMetadata_st;
#[doc = " Physical GPU metadata structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlVgpuPgpuMetadata_st {
    #[doc = "!< Current version of the structure"]
    pub version: ::std::os::raw::c_uint,
    #[doc = "!< Current revision of the structure"]
    pub revision: ::std::os::raw::c_uint,
    #[doc = "!< Host driver version"]
    pub hostDriverVersion: [::std::os::raw::c_char; 80usize],
    #[doc = "!< Pgpu virtualizaion capabilities bitfileld"]
    pub pgpuVirtualizationCaps: ::std::os::raw::c_uint,
    #[doc = "!< Reserved for internal use"]
    pub reserved: [::std::os::raw::c_uint; 5usize],
    #[doc = "!< vGPU version range supported by host driver"]
    pub hostSupportedVgpuRange: nvmlVgpuVersion_t,
    #[doc = "!< Size of opaque data field in bytes"]
    pub opaqueDataSize: ::std::os::raw::c_uint,
    #[doc = "!< Opaque data"]
    pub opaqueData: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout_nvmlVgpuPgpuMetadata_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuPgpuMetadata_st>(),
        128usize,
        concat!("Size of: ", stringify!(nvmlVgpuPgpuMetadata_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuPgpuMetadata_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuPgpuMetadata_st))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).revision as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).hostDriverVersion as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(hostDriverVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).pgpuVirtualizationCaps as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(pgpuVirtualizationCaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).reserved as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).hostSupportedVgpuRange as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(hostSupportedVgpuRange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).opaqueDataSize as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(opaqueDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuMetadata_st>())).opaqueData as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuMetadata_st),
            "::",
            stringify!(opaqueData)
        )
    );
}
pub type nvmlVgpuPgpuMetadata_t = nvmlVgpuPgpuMetadata_st;
#[doc = "!< vGPU is not runnable"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_NONE:
    nvmlVgpuVmCompatibility_enum = 0;
#[doc = "!< vGPU is runnable from a cold / powered-off state (ACPI S5)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_COLD:
    nvmlVgpuVmCompatibility_enum = 1;
#[doc = "!< vGPU is runnable from a hibernated state (ACPI S4)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_HIBERNATE:
    nvmlVgpuVmCompatibility_enum = 2;
#[doc = "!< vGPU is runnable from a sleeped state (ACPI S3)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_SLEEP:
    nvmlVgpuVmCompatibility_enum = 4;
#[doc = "!< vGPU is runnable from a live/paused (ACPI S0)"]
pub const nvmlVgpuVmCompatibility_enum_NVML_VGPU_VM_COMPATIBILITY_LIVE:
    nvmlVgpuVmCompatibility_enum = 8;
#[doc = " vGPU VM compatibility codes"]
pub type nvmlVgpuVmCompatibility_enum = u32;
pub use self::nvmlVgpuVmCompatibility_enum as nvmlVgpuVmCompatibility_t;
#[doc = "!< Compatibility is not limited."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_NONE:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 0;
#[doc = "!< ompatibility is limited by host driver version."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_HOST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 1;
#[doc = "!< Compatibility is limited by guest driver version."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GUEST_DRIVER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2;
#[doc = "!< Compatibility is limited by GPU hardware."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_GPU:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 4;
#[doc = "!< Compatibility is limited by an undefined factor."]
pub const nvmlVgpuPgpuCompatibilityLimitCode_enum_NVML_VGPU_COMPATIBILITY_LIMIT_OTHER:
    nvmlVgpuPgpuCompatibilityLimitCode_enum = 2147483648;
#[doc = "  vGPU-pGPU compatibility limit codes"]
pub type nvmlVgpuPgpuCompatibilityLimitCode_enum = u32;
pub use self::nvmlVgpuPgpuCompatibilityLimitCode_enum as nvmlVgpuPgpuCompatibilityLimitCode_t;
#[doc = " vGPU-pGPU compatibility structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nvmlVgpuPgpuCompatibility_st {
    #[doc = "!< Compatibility of vGPU VM. See \\ref nvmlVgpuVmCompatibility_t"]
    pub vgpuVmCompatibility: nvmlVgpuVmCompatibility_t,
    #[doc = "!< Limiting factor for vGPU-pGPU compatibility. See \\ref nvmlVgpuPgpuCompatibilityLimitCode_t"]
    pub compatibilityLimitCode: nvmlVgpuPgpuCompatibilityLimitCode_t,
}
#[test]
fn bindgen_test_layout_nvmlVgpuPgpuCompatibility_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlVgpuPgpuCompatibility_st>(),
        8usize,
        concat!("Size of: ", stringify!(nvmlVgpuPgpuCompatibility_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlVgpuPgpuCompatibility_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlVgpuPgpuCompatibility_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuCompatibility_st>())).vgpuVmCompatibility as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuCompatibility_st),
            "::",
            stringify!(vgpuVmCompatibility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlVgpuPgpuCompatibility_st>())).compatibilityLimitCode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlVgpuPgpuCompatibility_st),
            "::",
            stringify!(compatibilityLimitCode)
        )
    );
}
pub type nvmlVgpuPgpuCompatibility_t = nvmlVgpuPgpuCompatibility_st;
extern "C" {
    #[doc = " Returns vGPU metadata structure for a running vGPU. The structure contains information about the vGPU and its associated VM"]
    #[doc = " such as the currently installed NVIDIA guest driver version, together with host driver version and an opaque data section"]
    #[doc = " containing internal state."]
    #[doc = ""]
    #[doc = " nvmlVgpuInstanceGetMetadata() may be called at any time for a vGPU instance. Some fields in the returned structure are"]
    #[doc = " dependent on information obtained from the guest VM, which may not yet have reached a state where that information"]
    #[doc = " is available. The current state of these dependent fields is reflected in the info structure's \\ref nvmlVgpuGuestInfoState_t field."]
    #[doc = ""]
    #[doc = " The VMM may choose to read and save the vGPU's VM info as persistent metadata associated with the VM, and provide"]
    #[doc = " it to GRID Virtual GPU Manager when creating a vGPU for subsequent instances of the VM."]
    #[doc = ""]
    #[doc = " The caller passes in a buffer via \\a vgpuMetadata, with the size of the buffer in \\a bufferSize. If the vGPU Metadata structure"]
    #[doc = " is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed"]
    #[doc = " in \\a bufferSize."]
    #[doc = ""]
    #[doc = " @param vgpuInstance             vGPU instance handle"]
    #[doc = " @param vgpuMetadata             Pointer to caller-supplied buffer into which vGPU metadata is written"]
    #[doc = " @param bufferSize               Size of vgpuMetadata buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   vGPU metadata structure was successfully returned"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   vgpuMetadata buffer is too small, required size is returned in \\a bufferSize"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a bufferSize is NULL or \\a vgpuInstance is 0; if \\a vgpuMetadata is NULL and the value of \\a bufferSize is not 0."]
    #[doc = "         - \\ref NVML_ERROR_NOT_FOUND           if \\a vgpuInstance does not match a valid active vGPU instance on the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlVgpuInstanceGetMetadata(
        vgpuInstance: nvmlVgpuInstance_t,
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns a vGPU metadata structure for the physical GPU indicated by \\a device. The structure contains information about"]
    #[doc = " the GPU and the currently installed NVIDIA host driver version that's controlling it, together with an opaque data section"]
    #[doc = " containing internal state."]
    #[doc = ""]
    #[doc = " The caller passes in a buffer via \\a pgpuMetadata, with the size of the buffer in \\a bufferSize. If the \\a pgpuMetadata"]
    #[doc = " structure is too large to fit in the supplied buffer, the function returns NVML_ERROR_INSUFFICIENT_SIZE with the size needed"]
    #[doc = " in \\a bufferSize."]
    #[doc = ""]
    #[doc = " @param device                The identifier of the target device"]
    #[doc = " @param pgpuMetadata          Pointer to caller-supplied buffer into which \\a pgpuMetadata is written"]
    #[doc = " @param bufferSize            Pointer to size of \\a pgpuMetadata buffer"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   GPU metadata structure was successfully returned"]
    #[doc = "         - \\ref NVML_ERROR_INSUFFICIENT_SIZE   pgpuMetadata buffer is too small, required size is returned in \\a bufferSize"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a bufferSize is NULL or \\a device is invalid; if \\a pgpuMetadata is NULL and the value of \\a bufferSize is not 0."]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED       vGPU is not supported by the system"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlDeviceGetVgpuMetadata(
        device: nvmlDevice_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        bufferSize: *mut ::std::os::raw::c_uint,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Takes a vGPU instance metadata structure read from \\ref nvmlVgpuInstanceGetMetadata(), and a vGPU metadata structure for a"]
    #[doc = " physical GPU read from \\ref nvmlDeviceGetVgpuMetadata(), and returns compatibility information of the vGPU instance and the"]
    #[doc = " physical GPU."]
    #[doc = ""]
    #[doc = " The caller passes in a buffer via \\a compatibilityInfo, into which a compatibility information structure is written. The"]
    #[doc = " structure defines the states in which the vGPU / VM may be booted on the physical GPU. If the vGPU / VM compatibility"]
    #[doc = " with the physical GPU is limited, a limit code indicates the factor limiting compability."]
    #[doc = " (see \\ref nvmlVgpuPgpuCompatibilityLimitCode_t for details)."]
    #[doc = ""]
    #[doc = " Note: vGPU compatibility does not take into account dynamic capacity conditions that may limit a system's ability to"]
    #[doc = "       boot a given vGPU or associated VM."]
    #[doc = ""]
    #[doc = " @param vgpuMetadata          Pointer to caller-supplied vGPU metadata structure"]
    #[doc = " @param pgpuMetadata          Pointer to caller-supplied GPU metadata structure"]
    #[doc = " @param compatibilityInfo     Pointer to caller-supplied buffer to hold compatibility info"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   vGPU metadata structure was successfully returned"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT    if \\a vgpuMetadata or \\a pgpuMetadata or \\a bufferSize are NULL"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN             on any unexpected error"]
    pub fn nvmlGetVgpuCompatibility(
        vgpuMetadata: *mut nvmlVgpuMetadata_t,
        pgpuMetadata: *mut nvmlVgpuPgpuMetadata_t,
        compatibilityInfo: *mut nvmlVgpuPgpuCompatibility_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Returns the following two version range structures \\ref nvmlVgpuVersion_t :"]
    #[doc = " 1. \\a supported : structure representing the range of vGPU versions supported by the host;"]
    #[doc = " 2. \\a current : structure representing the range of supported versions enforced by the caller via \\ref nvmlSetVgpuVersion()."]
    #[doc = ""]
    #[doc = " The caller pass in the pointer to the structures, into which the compatible ranges are written."]
    #[doc = ""]
    #[doc = " @note: 1. The guest driver will fail to load if the version is below the range returned in the \\a current structure."]
    #[doc = "        2. If the guest driver is above the range, it will be downgraded to the current structure maximum version."]
    #[doc = ""]
    #[doc = " @param supported              Pointer to caller-supplied structure into which the supported vGPU version range is returned"]
    #[doc = " @param current                Pointer to caller-supplied structure into which the caller enforced supported vGPU version range is returned."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   vGPU version range structure was successfully returned"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED       API not supported"]
    #[doc = "         - \\ref NVML_ERROR_UNKNOWN             Error while getting the data"]
    pub fn nvmlGetVgpuVersion(
        supported: *mut nvmlVgpuVersion_t,
        current: *mut nvmlVgpuVersion_t,
    ) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Takes a vGPU version range structure \\ref nvmlVgpuVersion_t and set the vGPU compatible version range to the one provided as input."]
    #[doc = " The caller should call the \\ref nvmlGetVgpuVersion() to get the range of supported version by the host driver."]
    #[doc = ""]
    #[doc = " @note: 1. The guest driver will fail to load if the version is below the range set via \\a vgpuVersion structure."]
    #[doc = "        2. If the guest driver is above the range, it will be downgraded to the \\a vgpuVersion structure maximum version."]
    #[doc = "        3. This will result error if there are VMs already active on the host or the supported range being set is outside the range supported by host driver."]
    #[doc = ""]
    #[doc = " @param vgpuVersion          Pointer to caller-supplied vGPU supported version range."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                   vGPU metadata structure was successfully returned"]
    #[doc = "         - \\ref NVML_ERROR_NOT_SUPPORTED       API not supported"]
    #[doc = "         - \\ref NVML_ERROR_IN_USE              Range not set as VM is running on the host"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT    Range being set is outside the range supported by host driver"]
    pub fn nvmlSetVgpuVersion(vgpuVersion: *mut nvmlVgpuVersion_t) -> nvmlReturn_t;
}
#[doc = " Blacklist GPU device information"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nvmlBlacklistDeviceInfo_st {
    #[doc = "!< The PCI information for the blacklisted GPU"]
    pub pciInfo: nvmlPciInfo_t,
    #[doc = "!< The ASCII string UUID for the blacklisted GPU"]
    pub uuid: [::std::os::raw::c_char; 80usize],
}
#[test]
fn bindgen_test_layout_nvmlBlacklistDeviceInfo_st() {
    assert_eq!(
        ::std::mem::size_of::<nvmlBlacklistDeviceInfo_st>(),
        148usize,
        concat!("Size of: ", stringify!(nvmlBlacklistDeviceInfo_st))
    );
    assert_eq!(
        ::std::mem::align_of::<nvmlBlacklistDeviceInfo_st>(),
        4usize,
        concat!("Alignment of ", stringify!(nvmlBlacklistDeviceInfo_st))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<nvmlBlacklistDeviceInfo_st>())).pciInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBlacklistDeviceInfo_st),
            "::",
            stringify!(pciInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<nvmlBlacklistDeviceInfo_st>())).uuid as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(nvmlBlacklistDeviceInfo_st),
            "::",
            stringify!(uuid)
        )
    );
}
pub type nvmlBlacklistDeviceInfo_t = nvmlBlacklistDeviceInfo_st;
extern "C" {
    #[doc = " Retrieves the number of blacklisted GPU devices in the system."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " @param deviceCount                          Reference in which to return the number of blacklisted devices"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                 if \\a deviceCount has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT  if \\a deviceCount is NULL"]
    pub fn nvmlGetBlacklistDeviceCount(deviceCount: *mut ::std::os::raw::c_uint) -> nvmlReturn_t;
}
extern "C" {
    #[doc = " Acquire the device information for a blacklisted device, based on its index."]
    #[doc = ""]
    #[doc = " For all products."]
    #[doc = ""]
    #[doc = " Valid indices are derived from the \\a deviceCount returned by"]
    #[doc = "   \\ref nvmlGetBlacklistDeviceCount(). For example, if \\a deviceCount is 2 the valid indices"]
    #[doc = "   are 0 and 1, corresponding to GPU 0 and GPU 1."]
    #[doc = ""]
    #[doc = " @param index                                The index of the target GPU, >= 0 and < \\a deviceCount"]
    #[doc = " @param info                                 Reference in which to return the device information"]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "         - \\ref NVML_SUCCESS                  if \\a device has been set"]
    #[doc = "         - \\ref NVML_ERROR_INVALID_ARGUMENT   if \\a index is invalid or \\a info is NULL"]
    #[doc = ""]
    #[doc = " @see nvmlGetBlacklistDeviceCount"]
    pub fn nvmlGetBlacklistDeviceInfoByIndex(
        index: ::std::os::raw::c_uint,
        info: *mut nvmlBlacklistDeviceInfo_t,
    ) -> nvmlReturn_t;
}
